(* Do not modify. Generated by extraction from inverse_in_place.mlw. *)

let prefix_tl (x: Z.t) : Z.t = Z.sub (Z.neg x) Z.one

let inverse_in_place (a: (Z.t) array) : unit =
  let n = Z.of_int (Array.length a) in
  let o = Z.zero in
  let o1 = Z.sub n Z.one in
  let rec for_loop_to m =
    if Z.geq m o
    then begin
      (let i = ref (a.(Z.to_int m)) in
       if Z.geq (!i) Z.zero
       then begin
              a.(Z.to_int m) <- Z.of_string "-1";
              let j = ref (prefix_tl m) in
              let k = ref (!i) in
              i := a.(Z.to_int (!i));
              while Z.geq (!i) Z.zero do
                a.(Z.to_int (!k)) <- !j;
                j := prefix_tl (!k);
                k := !i;
                i := a.(Z.to_int (!k))
              done;
              i := !j
            end;
       a.(Z.to_int m) <- prefix_tl (!i));
      for_loop_to (Z.pred m)
    end
  in for_loop_to o1

let test1 (_: unit) : (Z.t) array =
  let a = Array.make (Z.to_int (Z.of_string "3")) Z.zero in
  a.(Z.to_int Z.zero) <- Z.of_string "2";
  a.(Z.to_int (Z.of_string "2")) <- Z.zero;
  a.(Z.to_int Z.one) <- Z.one;
  inverse_in_place a;
  a

let test2 (_: unit) : (Z.t) array =
  let a = Array.make (Z.to_int (Z.of_string "3")) Z.zero in
  a.(Z.to_int Z.zero) <- Z.one;
  a.(Z.to_int Z.one) <- Z.of_string "2";
  a.(Z.to_int (Z.of_string "2")) <- Z.zero;
  inverse_in_place a;
  a

