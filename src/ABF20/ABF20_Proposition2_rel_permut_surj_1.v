(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require map.Map.

Parameter size: Numbers.BinNums.Z.

Axiom Size_pos : (0%Z < size)%Z.

Axiom bnat : Type.
Parameter bnat_WhyType : WhyType bnat.
Existing Instance bnat_WhyType.

Parameter elt: bnat -> Numbers.BinNums.Z.

Axiom bnat'invariant :
  forall (self:bnat), (1%Z <= (elt self))%Z /\ ((elt self) <= size)%Z.

Parameter one_Bounded_nat: bnat.

Axiom one_Bounded_nat'def : ((elt one_Bounded_nat) = 1%Z).

Axiom Elt_inj : forall (n:bnat) (m:bnat), ((elt n) = (elt m)) -> (n = m).

Axiom eq_bnat_eq : forall (n:bnat) (m:bnat), (n = m) <-> ((elt n) = (elt m)).

(* Why3 assumption *)
Definition lt_bnat (i:bnat) (j:bnat) : Prop := ((elt i) < (elt j))%Z.

Axiom Trans :
  forall (x:bnat) (y:bnat) (z:bnat), lt_bnat x y -> lt_bnat y z ->
  lt_bnat x z.

Axiom Asymm : forall (x:bnat) (y:bnat), lt_bnat x y -> ~ lt_bnat y x.

Axiom Trichotomy :
  forall (x:bnat) (y:bnat), lt_bnat x y \/ lt_bnat y x \/ (x = y).

(* Why3 assumption *)
Definition injective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (i:a) (j:a), ((m i) = (m j)) -> (i = j).

(* Why3 assumption *)
Definition surjective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (j:b), exists i:a, ((m i) = j).

(* Why3 assumption *)
Definition bijective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  injective m /\ surjective m.

(* Why3 assumption *)
Definition map_rel (m:bnat -> bnat) (x:bnat) (y:bnat) : Prop := ((m x) = y).

Parameter m: bnat -> bnat.

Axiom Deter :
  forall (x:bnat), forall (y:bnat) (z:bnat), map_rel m x y ->
  map_rel m x z -> (y = z).

Axiom Total : forall (x:bnat), exists y:bnat, map_rel m x y.

Axiom a : Type.
Parameter a_WhyType : WhyType a.
Existing Instance a_WhyType.

Parameter rel: a -> a -> Prop.

Axiom Deter1 :
  forall (x:a), forall (y:a) (z:a), rel x y -> rel x z -> (y = z).

Axiom Total1 : forall (x:a), exists y:a, rel x y.

Axiom Injec :
  forall (x:a) (y:a), forall (a1:a) (b:a), rel x a1 -> rel y b -> (a1 = b) ->
  (x = y).

Axiom Surjec : forall (y:a), exists x:a, rel x y.

Parameter a2bnat: a -> bnat.

Parameter bnat2a: bnat -> a.

Axiom LeftInv : forall (x:a), ((bnat2a (a2bnat x)) = x).

Axiom Injec1 : forall (x:a) (y:a), ((a2bnat x) = (a2bnat y)) -> (x = y).

Axiom Surjec1 : forall (x:a), exists y:bnat, ((bnat2a y) = x).

Axiom LeftInv1 : forall (x:bnat), ((a2bnat (bnat2a x)) = x).

Axiom Injec2 :
  forall (x:bnat) (y:bnat), ((bnat2a x) = (bnat2a y)) -> (x = y).

Axiom Surjec2 : forall (x:bnat), exists y:a, ((a2bnat y) = x).

(* Why3 assumption *)
Definition isomorphic (sigma:bnat -> bnat) : Prop :=
  exists f:a -> bnat,
  bijective f /\ (forall (x:a) (y:a), rel x y <-> map_rel sigma (f x) (f y)).

Axiom Deter2 :
  forall (x:a), forall (y:a) (z:a), rel x y -> rel x z -> (y = z).

Axiom Total2 : forall (x:a), exists y:a, rel x y.

Axiom ex_map :
  exists m1:a -> a, forall (x:a), forall (y:a), ((m1 x) = y) <-> rel x y.

Parameter rel_map: a -> a.

Axiom rel_map'def :
  forall (i:a), forall (j:a), ((rel_map i) = j) <-> rel i j.

Axiom rel_map_surj : surjective rel_map.

Axiom rel_map_bij : bijective rel_map.

Parameter rel_permut: bnat -> bnat.

Axiom rel_permut'def :
  forall (i:bnat) (j:bnat),
  ((rel_permut i) = j) <-> ((rel_map (bnat2a i)) = (bnat2a j)).

Axiom rel_permut_prop :
  forall (x:a) (y:a), rel x y <-> ((rel_permut (a2bnat x)) = (a2bnat y)).

(* Why3 goal *)
Theorem rel_permut_surj : surjective rel_permut.
Proof.
unfold surjective.
intro j.
destruct (Surjec2 j) as [y Y].
destruct (rel_map_surj y) as [x X].
exists (a2bnat x).
apply rel_permut'def.
rewrite <- Y.
rewrite LeftInv.
rewrite LeftInv.
apply X.
Qed.

