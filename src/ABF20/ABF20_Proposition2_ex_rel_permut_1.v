(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.NumOf.
Require map.Map.

Parameter low: Numbers.BinNums.Z.

Parameter up: Numbers.BinNums.Z.

Axiom Nonempty : (low <= up)%Z.

Axiom bint : Type.
Parameter bint_WhyType : WhyType bint.
Existing Instance bint_WhyType.

Parameter to_int: bint -> Numbers.BinNums.Z.

Axiom bint'invariant :
  forall (self:bint), (low <= (to_int self))%Z /\ ((to_int self) <= up)%Z.

Parameter low_bint: bint.

Axiom low_bint'def : ((to_int low_bint) = low).

Axiom Extensionality :
  forall (i:bint) (j:bint), ((to_int i) = (to_int j)) -> (i = j).

(* Why3 assumption *)
Definition lt_bint (i:bint) (j:bint) : Prop := ((to_int i) < (to_int j))%Z.

Axiom Trans :
  forall (x:bint) (y:bint) (z:bint), lt_bint x y -> lt_bint y z ->
  lt_bint x z.

Axiom Asymm : forall (x:bint) (y:bint), lt_bint x y -> ~ lt_bint y x.

Axiom Trichotomy :
  forall (x:bint) (y:bint), lt_bint x y \/ lt_bint y x \/ (x = y).

Parameter of_int: Numbers.BinNums.Z -> bint.

Axiom of_int'spec :
  forall (i:Numbers.BinNums.Z), (low <= i)%Z /\ (i <= up)%Z ->
  ((to_int (of_int i)) = i).

Axiom of_int_quasi_inj :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (low <= i)%Z /\ (i <= up)%Z -> (low <= j)%Z /\ (j <= up)%Z ->
  ((of_int i) = (of_int j)) -> (i = j).

Axiom of_intK : forall (i:bint), ((of_int (to_int i)) = i).

Parameter result:
  (bint -> Init.Datatypes.bool) -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom result'def :
  forall (p:bint -> Init.Datatypes.bool) (i:Numbers.BinNums.Z),
  ((result p i) = Init.Datatypes.true) <->
  ((low <= i)%Z /\ (i <= up)%Z) /\ ((p (of_int i)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition numof_bint (p:bint -> Init.Datatypes.bool) (a:bint) (b:bint) :
    Numbers.BinNums.Z :=
  int.NumOf.numof (result p) (to_int a) (to_int b).

(* Why3 assumption *)
Definition injective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (i:a) (j:a), ((m i) = (m j)) -> (i = j).

(* Why3 assumption *)
Definition surjective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (j:b), exists i:a, ((m i) = j).

(* Why3 assumption *)
Definition bijective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  injective m /\ surjective m.

Axiom a : Type.
Parameter a_WhyType : WhyType a.
Existing Instance a_WhyType.

Parameter rel: a -> a -> Prop.

Axiom Deter :
  forall (x:a), forall (y:a) (z:a), rel x y -> rel x z -> (y = z).

Axiom Total : forall (x:a), exists y:a, rel x y.

Axiom Injec :
  forall (x:a) (y:a), forall (a1:a), rel x a1 -> rel y a1 -> (x = y).

Axiom Surjec : forall (y:a), exists x:a, rel x y.

Parameter a2bint: a -> bint.

Parameter bint2a: bint -> a.

Axiom Cancel : forall (x:a), ((bint2a (a2bint x)) = x).

Axiom Injec1 : forall (x:a) (y:a), ((a2bint x) = (a2bint y)) -> (x = y).

Axiom Surjec1 : forall (x:a), exists y:bint, ((bint2a y) = x).

Axiom Cancel1 : forall (x:bint), ((a2bint (bint2a x)) = x).

Axiom Injec2 :
  forall (x:bint) (y:bint), ((bint2a x) = (bint2a y)) -> (x = y).

Axiom Surjec2 : forall (x:bint), exists y:a, ((a2bint y) = x).

(* Why3 assumption *)
Definition map_rel {a1:Type} {a1_WT:WhyType a1} {b:Type} {b_WT:WhyType b}
    (m:a1 -> b) (x:a1) (y:b) : Prop :=
  ((m x) = y).

(* Why3 assumption *)
Definition isomorphic (sigma:bint -> bint) : Prop :=
  exists f:a -> bint,
  bijective f /\ (forall (x:a) (y:a), rel x y <-> map_rel sigma (f x) (f y)).

(* Why3 goal *)
Theorem ex_rel_permut :
  exists rel_permut:bint -> bint,
  forall (i:bint) (j:bint),
  ((rel_permut i) = j) <-> rel (bint2a i) (bint2a j).
Proof.
destruct (Logic.ClassicalEpsilon.choice rel Total) as [f H].
exists (fun i => a2bint (f (bint2a i))).
split; intro F.
- rewrite <- F. rewrite Cancel. apply H.
- apply eq_sym. apply Injec2. rewrite Cancel.
  apply Deter with (x := bint2a i). apply F. apply H.
Qed.

