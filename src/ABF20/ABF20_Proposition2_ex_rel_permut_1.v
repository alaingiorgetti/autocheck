(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.NumOf.
Require map.Map.

Parameter low: Numbers.BinNums.Z.

Parameter up: Numbers.BinNums.Z.

Axiom Nonempty : (low <= up)%Z.

Axiom intvl : Type.
Parameter intvl_WhyType : WhyType intvl.
Existing Instance intvl_WhyType.

Parameter elt: intvl -> Numbers.BinNums.Z.

Axiom intvl'invariant :
  forall (self:intvl), (low <= (elt self))%Z /\ ((elt self) <= up)%Z.

Axiom Elt_inj : forall (n:intvl) (m:intvl), ((elt n) = (elt m)) -> (n = m).

Parameter low_intvl: intvl.

Axiom low_intvl'def : ((elt low_intvl) = low).

(* Why3 assumption *)
Definition eq_intvl (i:intvl) (j:intvl) : Prop := ((elt i) = (elt j)).

Axiom eq_intvl_eq : forall (i:intvl) (j:intvl), (i = j) <-> eq_intvl i j.

(* Why3 assumption *)
Definition lt_intvl (i:intvl) (j:intvl) : Prop := ((elt i) < (elt j))%Z.

Axiom Trans :
  forall (x:intvl) (y:intvl) (z:intvl), lt_intvl x y -> lt_intvl y z ->
  lt_intvl x z.

Axiom Asymm : forall (x:intvl) (y:intvl), lt_intvl x y -> ~ lt_intvl y x.

Axiom Trichotomy :
  forall (x:intvl) (y:intvl), lt_intvl x y \/ lt_intvl y x \/ (x = y).

Parameter int2intvl: Numbers.BinNums.Z -> intvl.

Axiom int2intvl'spec :
  forall (i:Numbers.BinNums.Z), (low <= i)%Z /\ (i <= up)%Z ->
  ((elt (int2intvl i)) = i).

Axiom int2intvl_quasi_inj :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (low <= i)%Z /\ (i <= up)%Z -> (low <= j)%Z /\ (j <= up)%Z ->
  ((int2intvl i) = (int2intvl j)) -> (i = j).

Parameter result:
  (intvl -> Init.Datatypes.bool) -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom result'def :
  forall (p:intvl -> Init.Datatypes.bool) (i:Numbers.BinNums.Z),
  ((result p i) = Init.Datatypes.true) <->
  ((low <= i)%Z /\ (i <= up)%Z) /\ ((p (int2intvl i)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition numof_intvl (p:intvl -> Init.Datatypes.bool) (a:intvl) (b:intvl) :
    Numbers.BinNums.Z :=
  int.NumOf.numof (result p) (elt a) (elt b).

(* Why3 assumption *)
Definition for_all_sub_pred (p:intvl -> Init.Datatypes.bool)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (l <= i)%Z /\ (i <= u)%Z ->
  ((p (int2intvl i)) = Init.Datatypes.true).

Parameter for_all_sub:
  (intvl -> Init.Datatypes.bool) -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Init.Datatypes.bool.

Axiom for_all_sub'spec :
  forall (p:intvl -> Init.Datatypes.bool) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  (low <= l)%Z /\ (l <= up)%Z -> (low <= u)%Z /\ (u <= up)%Z ->
  ((for_all_sub p l u) = Init.Datatypes.true) <-> for_all_sub_pred p l u.

Parameter for_all: (intvl -> Init.Datatypes.bool) -> Init.Datatypes.bool.

Axiom for_all'spec :
  forall (p:intvl -> Init.Datatypes.bool),
  ((for_all p) = Init.Datatypes.true) <-> for_all_sub_pred p low up.

(* Why3 assumption *)
Definition injective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (i:a) (j:a), ((m i) = (m j)) -> (i = j).

(* Why3 assumption *)
Definition surjective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (j:b), exists i:a, ((m i) = j).

(* Why3 assumption *)
Definition bijective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  injective m /\ surjective m.

Axiom a : Type.
Parameter a_WhyType : WhyType a.
Existing Instance a_WhyType.

Parameter rel: a -> a -> Prop.

Axiom Deter :
  forall (x:a), forall (y:a) (z:a), rel x y -> rel x z -> (y = z).

Axiom Total : forall (x:a), exists y:a, rel x y.

Axiom Injec :
  forall (x:a) (y:a), forall (a1:a) (b:a), rel x a1 -> rel y b -> (a1 = b) ->
  (x = y).

Axiom Surjec : forall (y:a), exists x:a, rel x y.

Parameter a2intvl: a -> intvl.

Parameter intvl2a: intvl -> a.

Axiom Cancel : forall (x:a), ((intvl2a (a2intvl x)) = x).

Axiom Injec1 : forall (x:a) (y:a), ((a2intvl x) = (a2intvl y)) -> (x = y).

Axiom Surjec1 : forall (x:a), exists y:intvl, ((intvl2a y) = x).

Axiom Cancel1 : forall (x:intvl), ((a2intvl (intvl2a x)) = x).

Axiom Injec2 :
  forall (x:intvl) (y:intvl), ((intvl2a x) = (intvl2a y)) -> (x = y).

Axiom Surjec2 : forall (x:intvl), exists y:a, ((a2intvl y) = x).

(* Why3 assumption *)
Definition map_rel {a1:Type} {a1_WT:WhyType a1} {b:Type} {b_WT:WhyType b}
    (m:a1 -> b) (x:a1) (y:b) : Prop :=
  ((m x) = y).

(* Why3 assumption *)
Definition isomorphic (sigma:intvl -> intvl) : Prop :=
  exists f:a -> intvl,
  bijective f /\ (forall (x:a) (y:a), rel x y <-> map_rel sigma (f x) (f y)).

(* Why3 goal *)
Theorem ex_rel_permut :
  exists rel_permut:intvl -> intvl,
  forall (i:intvl) (j:intvl),
  ((rel_permut i) = j) <-> rel (intvl2a i) (intvl2a j).
Proof.
destruct (Logic.ClassicalEpsilon.choice rel Total) as [f H].
exists (fun i => a2intvl (f (intvl2a i))).
split; intro F.
- rewrite <- F. rewrite Cancel. apply H.
- apply eq_sym. apply Injec2. rewrite Cancel.
  apply Deter with (x := intvl2a i). apply F. apply H.
Qed.

