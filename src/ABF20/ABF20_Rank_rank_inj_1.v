(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.NumOf.
Require map.Map.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom Numof_no_add :
  forall (p:Numbers.BinNums.Z -> Init.Datatypes.bool) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  (a <= b)%Z /\ (b < c)%Z -> ~ ((p b) = Init.Datatypes.true) ->
  ((int.NumOf.numof p a c) =
   ((int.NumOf.numof p a b) + (int.NumOf.numof p (b + 1%Z)%Z c))%Z).

(* Why3 assumption *)
Definition injective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (i:a) (j:a), ((m i) = (m j)) -> (i = j).

(* Why3 assumption *)
Definition surjective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (j:b), exists i:a, ((m i) = j).

(* Why3 assumption *)
Definition bijective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  injective m /\ surjective m.

Parameter low: Numbers.BinNums.Z.

Parameter up: Numbers.BinNums.Z.

Axiom Nonempty : (low <= up)%Z.

Axiom bint : Type.
Parameter bint_WhyType : WhyType bint.
Existing Instance bint_WhyType.

Parameter to_int: bint -> Numbers.BinNums.Z.

Axiom bint'invariant :
  forall (self:bint), (low <= (to_int self))%Z /\ ((to_int self) <= up)%Z.

Parameter low_bint: bint.

Axiom low_bint'def : ((to_int low_bint) = low).

Axiom Extensionality :
  forall (i:bint) (j:bint), ((to_int i) = (to_int j)) -> (i = j).

(* Why3 assumption *)
Definition lt_bint (i:bint) (j:bint) : Prop := ((to_int i) < (to_int j))%Z.

Axiom Trans :
  forall (x:bint) (y:bint) (z:bint), lt_bint x y -> lt_bint y z ->
  lt_bint x z.

Axiom Asymm : forall (x:bint) (y:bint), lt_bint x y -> ~ lt_bint y x.

Axiom Trichotomy :
  forall (x:bint) (y:bint), lt_bint x y \/ lt_bint y x \/ (x = y).

Parameter of_int: Numbers.BinNums.Z -> bint.

Axiom of_int'spec :
  forall (i:Numbers.BinNums.Z), (low <= i)%Z /\ (i <= up)%Z ->
  ((to_int (of_int i)) = i).

Axiom of_int_quasi_inj :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (low <= i)%Z /\ (i <= up)%Z -> (low <= j)%Z /\ (j <= up)%Z ->
  ((of_int i) = (of_int j)) -> (i = j).

Axiom of_intK : forall (i:bint), ((of_int (to_int i)) = i).

Parameter result:
  (bint -> Init.Datatypes.bool) -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom result'def :
  forall (p:bint -> Init.Datatypes.bool) (i:Numbers.BinNums.Z),
  ((result p i) = Init.Datatypes.true) <->
  ((low <= i)%Z /\ (i <= up)%Z) /\ ((p (of_int i)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition numof_bint (p:bint -> Init.Datatypes.bool) (a:bint) (b:bint) :
    Numbers.BinNums.Z :=
  int.NumOf.numof (result p) (to_int a) (to_int b).

(* Why3 assumption *)
Definition trans (rel:bint -> bint -> Init.Datatypes.bool) : Prop :=
  forall (x:bint) (y:bint) (z:bint), ((rel x y) = Init.Datatypes.true) ->
  ((rel y z) = Init.Datatypes.true) -> ((rel x z) = Init.Datatypes.true).

(* Why3 assumption *)
Definition asymm (rel:bint -> bint -> Init.Datatypes.bool) : Prop :=
  forall (x:bint) (y:bint), ((rel x y) = Init.Datatypes.true) ->
  ~ ((rel y x) = Init.Datatypes.true).

(* Why3 assumption *)
Definition partialStrictOrder (rel:bint -> bint -> Init.Datatypes.bool) :
    Prop :=
  trans rel /\ asymm rel.

(* Why3 assumption *)
Definition trichotomy (rel:bint -> bint -> Init.Datatypes.bool) : Prop :=
  forall (x:bint) (y:bint),
  ((rel x y) = Init.Datatypes.true) \/
  ((rel y x) = Init.Datatypes.true) \/ (x = y).

(* Why3 assumption *)
Definition totalStrictOrder (rel:bint -> bint -> Init.Datatypes.bool) : Prop :=
  partialStrictOrder rel /\ trichotomy rel.

Axiom irrefl :
  forall (lt:bint -> bint -> Init.Datatypes.bool), asymm lt ->
  forall (a:bint), ((lt a a) = Init.Datatypes.false).

(* Why3 assumption *)
Definition lt_int (lt:bint -> bint -> Init.Datatypes.bool) (a:bint)
    (j:Numbers.BinNums.Z) : Prop :=
  ((low <= j)%Z /\ (j <= up)%Z) /\ ((lt (of_int j) a) = Init.Datatypes.true).

Parameter lt_int_closure:
  (bint -> bint -> Init.Datatypes.bool) ->
  bint -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom lt_int_closure_def :
  forall (y:bint -> bint -> Init.Datatypes.bool) (y1:bint)
    (y2:Numbers.BinNums.Z),
  ((lt_int_closure y y1 y2) = Init.Datatypes.true) <-> lt_int y y1 y2.

Axiom numof_max :
  forall (lt:bint -> bint -> Init.Datatypes.bool), asymm lt ->
  forall (a:bint),
  ((int.NumOf.numof (lt_int_closure lt a) low (up + 1%Z)%Z) <=
   (up - low)%Z)%Z.

Parameter rank: (bint -> bint -> Init.Datatypes.bool) -> bint -> bint.

Axiom rank'def :
  forall (lt:bint -> bint -> Init.Datatypes.bool) (a:bint),
  totalStrictOrder lt ->
  ((rank lt a) =
   (of_int
    ((int.NumOf.numof (lt_int_closure lt a) low (up + 1%Z)%Z) + low)%Z)).

Require Import Lia.

(* Why3 goal *)
Theorem rank_lt_inj :
  forall (lt:bint -> bint -> Init.Datatypes.bool), totalStrictOrder lt ->
  injective
  ((fun (y0:bint -> bint -> Init.Datatypes.bool) (y1:bint) => rank y0 y1) lt).
(* Why3 intros lt h1. *)
Proof.
intros lt Sto.
unfold injective. intros i j.
rewrite rank'def; try apply Sto.
rewrite rank'def; try apply Sto.
unfold totalStrictOrder in Sto.
destruct Sto as [Spo Tricho].
destruct Spo as [Trans Asymm].
unfold trans in Trans.
unfold trichotomy in Tricho.
destruct (Tricho i j) as [L|[G|E]].
- { (* L : lt i j = true *)
 assert (NumOf.numof (lt_int_closure lt i) low (up + 1) < NumOf.numof (lt_int_closure lt j) low (up + 1))%Z as A.
 - {
  apply NumOf.numof_change_some with (i := to_int i); auto.
  - destruct (bint'invariant i). lia.
  - {
   intros k K I. apply lt_int_closure_def in I. apply lt_int_closure_def.
   unfold lt_int. split.
   - lia.
   - unfold lt_int in I.
    apply Trans with (y := i). apply I. apply L.
  }
  - {
   intro C. apply lt_int_closure_def in C. unfold lt_int in C.
   rewrite of_intK in C.
   rewrite irrefl in C.
   - destruct C as [D E]. discriminate E.
   - apply Asymm.
  }
  - {
   apply lt_int_closure_def. unfold lt_int. split.
   - apply (bint'invariant i).
   - rewrite of_intK. apply L.
  }
 }
 - {
  intro H. 
  apply of_int_quasi_inj in H.
  - lia.
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt i) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt i) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt j) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt j) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
 }
}
- { (* G : lt j i = true *)
 assert (NumOf.numof (lt_int_closure lt j) low (up + 1) < NumOf.numof (lt_int_closure lt i) low (up + 1))%Z as A.
 - {
  apply NumOf.numof_change_some with (i := to_int j); auto.
  - destruct (bint'invariant j). lia.
  - {
   intros k K I. apply lt_int_closure_def in I. apply lt_int_closure_def.
   unfold lt_int. split.
   - lia.
   - unfold lt_int in I.
    apply Trans with (y := j). apply I. apply G.
  }
  - {
   intro C. apply lt_int_closure_def in C. unfold lt_int in C.
   rewrite of_intK in C.
   rewrite irrefl in C.
   - destruct C as [D E]. discriminate E.
   - apply Asymm.
  }
  - {
   apply lt_int_closure_def. unfold lt_int. split.
   - apply bint'invariant.
   - rewrite of_intK. apply G.
  }
 }
 - {
  intro H.
  apply of_int_quasi_inj in H.
  - lia.
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt i) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt i) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt j) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt j) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
 }
}
- auto.
Qed.

