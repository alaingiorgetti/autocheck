(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.NumOf.
Require map.Map.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom Numof_no_add :
  forall (p:Numbers.BinNums.Z -> Init.Datatypes.bool) (a:Numbers.BinNums.Z)
    (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  (a <= b)%Z /\ (b < c)%Z -> ~ ((p b) = Init.Datatypes.true) ->
  ((int.NumOf.numof p a c) =
   ((int.NumOf.numof p a b) + (int.NumOf.numof p (b + 1%Z)%Z c))%Z).

(* Why3 assumption *)
Definition injective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (i:a) (j:a), ((m i) = (m j)) -> (i = j).

(* Why3 assumption *)
Definition surjective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  forall (j:b), exists i:a, ((m i) = j).

(* Why3 assumption *)
Definition bijective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (m:a -> b) : Prop :=
  injective m /\ surjective m.

Parameter low: Numbers.BinNums.Z.

Parameter up: Numbers.BinNums.Z.

Axiom Nonempty : (low <= up)%Z.

Axiom intvl : Type.
Parameter intvl_WhyType : WhyType intvl.
Existing Instance intvl_WhyType.

Parameter elt: intvl -> Numbers.BinNums.Z.

Axiom intvl'invariant :
  forall (self:intvl), (low <= (elt self))%Z /\ ((elt self) <= up)%Z.

Axiom Elt_inj : forall (n:intvl) (m:intvl), ((elt n) = (elt m)) -> (n = m).

Parameter low_intvl: intvl.

Axiom low_intvl'def : ((elt low_intvl) = low).

(* Why3 assumption *)
Definition eq_intvl (i:intvl) (j:intvl) : Prop := ((elt i) = (elt j)).

Axiom eq_intvl_eq : forall (i:intvl) (j:intvl), (i = j) <-> eq_intvl i j.

(* Why3 assumption *)
Definition lt_intvl (i:intvl) (j:intvl) : Prop := ((elt i) < (elt j))%Z.

Axiom Trans :
  forall (x:intvl) (y:intvl) (z:intvl), lt_intvl x y -> lt_intvl y z ->
  lt_intvl x z.

Axiom Asymm : forall (x:intvl) (y:intvl), lt_intvl x y -> ~ lt_intvl y x.

Axiom Trichotomy :
  forall (x:intvl) (y:intvl), lt_intvl x y \/ lt_intvl y x \/ (x = y).

Parameter int2intvl: Numbers.BinNums.Z -> intvl.

Axiom int2intvl'spec :
  forall (i:Numbers.BinNums.Z), (low <= i)%Z /\ (i <= up)%Z ->
  ((elt (int2intvl i)) = i).

Axiom int2intvl_quasi_inj :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (low <= i)%Z /\ (i <= up)%Z -> (low <= j)%Z /\ (j <= up)%Z ->
  ((int2intvl i) = (int2intvl j)) -> (i = j).

Axiom int2intvlK : forall (i:intvl), ((int2intvl (elt i)) = i).

Parameter result:
  (intvl -> Init.Datatypes.bool) -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom result'def :
  forall (p:intvl -> Init.Datatypes.bool) (i:Numbers.BinNums.Z),
  ((result p i) = Init.Datatypes.true) <->
  ((low <= i)%Z /\ (i <= up)%Z) /\ ((p (int2intvl i)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition numof_intvl (p:intvl -> Init.Datatypes.bool) (a:intvl) (b:intvl) :
    Numbers.BinNums.Z :=
  int.NumOf.numof (result p) (elt a) (elt b).

(* Why3 assumption *)
Definition trans (rel:intvl -> intvl -> Init.Datatypes.bool) : Prop :=
  forall (x:intvl) (y:intvl) (z:intvl), ((rel x y) = Init.Datatypes.true) ->
  ((rel y z) = Init.Datatypes.true) -> ((rel x z) = Init.Datatypes.true).

(* Why3 assumption *)
Definition asymm (rel:intvl -> intvl -> Init.Datatypes.bool) : Prop :=
  forall (x:intvl) (y:intvl), ((rel x y) = Init.Datatypes.true) ->
  ~ ((rel y x) = Init.Datatypes.true).

(* Why3 assumption *)
Definition partialStrictOrder (rel:intvl -> intvl -> Init.Datatypes.bool) :
    Prop :=
  trans rel /\ asymm rel.

(* Why3 assumption *)
Definition trichotomy (rel:intvl -> intvl -> Init.Datatypes.bool) : Prop :=
  forall (x:intvl) (y:intvl),
  ((rel x y) = Init.Datatypes.true) \/
  ((rel y x) = Init.Datatypes.true) \/ (x = y).

(* Why3 assumption *)
Definition totalStrictOrder (rel:intvl -> intvl -> Init.Datatypes.bool) :
    Prop :=
  partialStrictOrder rel /\ trichotomy rel.

Axiom irrefl :
  forall (lt:intvl -> intvl -> Init.Datatypes.bool), asymm lt ->
  forall (a:intvl), ((lt a a) = Init.Datatypes.false).

(* Why3 assumption *)
Definition lt_int (lt:intvl -> intvl -> Init.Datatypes.bool) (a:intvl)
    (j:Numbers.BinNums.Z) : Prop :=
  ((low <= j)%Z /\ (j <= up)%Z) /\
  ((lt (int2intvl j) a) = Init.Datatypes.true).

Parameter lt_int_closure:
  (intvl -> intvl -> Init.Datatypes.bool) ->
  intvl -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom lt_int_closure_def :
  forall (y:intvl -> intvl -> Init.Datatypes.bool) (y1:intvl)
    (y2:Numbers.BinNums.Z),
  ((lt_int_closure y y1 y2) = Init.Datatypes.true) <-> lt_int y y1 y2.

Axiom numof_max :
  forall (lt:intvl -> intvl -> Init.Datatypes.bool), asymm lt ->
  forall (a:intvl),
  ((int.NumOf.numof (lt_int_closure lt a) low (up + 1%Z)%Z) <=
   (up - low)%Z)%Z.

Parameter rank: (intvl -> intvl -> Init.Datatypes.bool) -> intvl -> intvl.

Axiom rank'def :
  forall (lt:intvl -> intvl -> Init.Datatypes.bool) (a:intvl),
  totalStrictOrder lt ->
  ((rank lt a) =
   (int2intvl
    ((int.NumOf.numof (lt_int_closure lt a) low (up + 1%Z)%Z) + low)%Z)).

Require Import Lia.

(* Why3 goal *)
Theorem rank_lt_inj :
  forall (lt:intvl -> intvl -> Init.Datatypes.bool), totalStrictOrder lt ->
  injective
  ((fun (y0:intvl -> intvl -> Init.Datatypes.bool) (y1:intvl) => rank y0 y1)
   lt).
(* Why3 intros lt h1. *)
Proof.
intros lt Sto.
unfold injective. intros i j.
rewrite rank'def; try apply Sto.
rewrite rank'def; try apply Sto.
unfold totalStrictOrder in Sto.
destruct Sto as [Spo Tricho].
destruct Spo as [Trans Asymm].
unfold trans in Trans.
unfold trichotomy in Tricho.
destruct (Tricho i j) as [L|[G|E]].
- { (* L : lt i j = true *)
 assert (NumOf.numof (lt_int_closure lt i) low (up + 1) < NumOf.numof (lt_int_closure lt j) low (up + 1))%Z as A.
 - {
  apply NumOf.numof_change_some with (i := elt i); auto.
  - destruct (intvl'invariant i). lia.
  - {
   intros k K I. apply lt_int_closure_def in I. apply lt_int_closure_def.
   unfold lt_int. split.
   - lia.
   - unfold lt_int in I.
    apply Trans with (y := i). apply I. apply L.
  }
  - {
   intro C. apply lt_int_closure_def in C. unfold lt_int in C.
   rewrite int2intvlK in C.
   rewrite irrefl in C.
   - destruct C as [D E]. discriminate E.
   - apply Asymm.
  }
  - {
   apply lt_int_closure_def. unfold lt_int. split.
   - apply (intvl'invariant i).
   - rewrite int2intvlK. apply L.
  }
 }
 - {
  intro H. apply eq_intvl_eq in H.
  apply eq_intvl_eq in H.
  apply int2intvl_quasi_inj in H.
  - lia.
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt i) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt i) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt j) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt j) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
 }
}
- { (* G : lt j i = true *)
 assert (NumOf.numof (lt_int_closure lt j) low (up + 1) < NumOf.numof (lt_int_closure lt i) low (up + 1))%Z as A.
 - {
  apply NumOf.numof_change_some with (i := elt j); auto.
  - destruct (intvl'invariant j). lia.
  - {
   intros k K I. apply lt_int_closure_def in I. apply lt_int_closure_def.
   unfold lt_int. split.
   - lia.
   - unfold lt_int in I.
    apply Trans with (y := j). apply I. apply G.
  }
  - {
   intro C. apply lt_int_closure_def in C. unfold lt_int in C.
   rewrite int2intvlK in C.
   rewrite irrefl in C.
   - destruct C as [D E]. discriminate E.
   - apply Asymm.
  }
  - {
   apply lt_int_closure_def. unfold lt_int. split.
   - apply intvl'invariant.
   - rewrite int2intvlK. apply G.
  }
 }
 - {
  intro H. apply eq_intvl_eq in H.
  apply eq_intvl_eq in H.
  apply int2intvl_quasi_inj in H.
  - lia.
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt i) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt i) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
  - {
   split.
   - {
    assert (0 <= NumOf.numof (lt_int_closure lt j) low (up + 1))%Z as B.
    - apply NumOf.numof_nat.
    - lia.
   }
   - {
    assert (NumOf.numof (lt_int_closure lt j) low (up + 1) <= up-low)%Z as B.
    - apply numof_max. apply Asymm.
    - lia.
   }
  }
 }
}
- auto.
Qed.

