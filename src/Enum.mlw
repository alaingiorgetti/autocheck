(********************************************************************)
(* Copyright (C) 2020-2021 Alain Giorgetti, Clotilde Erard and      *)
(*                                          JÃ©rome Ricciardi        *)
(* FEMTO-ST institute                                               *)
(********************************************************************)

(********************************************************************)
(*  This software is distributed under the terms of the GNU Lesser  *)
(*  General Public License version 2.1                              *)
(********************************************************************)


(* Allmost all the WhyML code of ENUM 1.3 in a single file.

   Exceptions are:
   
   - modules Test and some modules *Sound in generator/**/*.mlw
   
   Differences are:
   
   - module Enum in Xxx.mlw is renamed XxxEnum
   
   - lex.Lex -> Lex
   
   - lexList.Lex -> LexList
   
   - listExtension.ArrayList -> ArrayList
   
   - arrayExtension.Array -> Array
   - arrayExtension.ArrayInjection -> ArrayInjection
   - arrayExtension.Cte -> ArrayCte
   - arrayExtension.Inc -> ArrayInc
   - arrayExtension.ToList -> ToList
   - arrayExtension.Id -> ArrayId
   
   - listExtension.ListLengthExtension -> ListLengthExtension
   - listExtension.listExtension -> ListExtension
   - listExtension.ArrayList -> ArrayList
   - listExtension.CteList -> ListCte
   - listExtension.ListEq -> ListEq
   
   - lexgen.Cursor -> Cursor
   - lexgen.LexXX -> LexXX
   - lexgen.LexIntXX -> LexIntXX
   - lexgen.SmallCheck -> SmallCheck
   - lexgen.SmallCheckInt -> SmallCheckInt
   - lexgen.FilterInt -> FilterInt
   
   - lexgenList.Cursor -> CursorList
   - lexgenList.LexIntXX -> LexIntXXList
   - lexgenList.SmallCheckInt -> SmallCheckIntList
   
   - Xxx.Xxx -> Xxx for Endo, Barray, ...
   - Xxx.Enum -> XxxEnum for Endo, Barray, ...
*)


(* From arrayExtension.mlw: *)

(* Extensions of stdlib/array.mlw *)

module Array

  use int.Int
  use array.Array

  let copy (a b: array int) : unit
    requires { b.length = a.length }
    ensures  { forall i. 0 <= i < a.length -> b[i] = a[i] }
  =
    for i = 0 to a.length-1 do
      invariant { forall j. 0 <= j < i -> b[j] = a[j] }
      b[i] <- a[i]
    done

end


(** Restriction of map.MapInjection to arrays. *)

theory ArrayInjection
  use int.Int
  use ref.Ref
  use array.Array
  use map.MapInjection as M
  use map.Occ

  predicate injective (a: array int) = M.injective a.elts a.length
  predicate surjective (a: array int) = M.surjective a.elts a.length
  predicate range (a: array int) = M.range a.elts a.length

  lemma injective_surjective: forall a: array int.
    injective a -> range a -> surjective a

  lemma injection_occ: forall a: array int.
    injective a <-> forall v:int. (occ v a.elts 0 a.length <= 1)

  lemma endoinjection_occ: [@split_all_full] forall a: array int. 
    M.range (a.elts) a.length /\ injective a
    -> forall v:int. 0 <= v < a.length
    -> occ v a.elts 0 a.length = 1

  let predicate in_interval (x l u: int) = l <= x < u

  (* The following two predicates could be generalized to maps and added to 
     module MapInjection in stdlib/map.mlw. *)
  predicate range_sub (a: array int) (l u b: int) = forall i: int.
    l <= i < u -> in_interval a[i] 0 b

  predicate inj_sub (a: array int) (l u: int) = forall i: int.
    l <= i < u -> forall j: int. l <= j < u -> i <> j -> a.elts i <> a.elts j

  (* The following predicates and Boolean functions 
     are used for BET in generator/permutation/Permutation.mlw *) 
  predicate diff_sub (a: array int) (i: int) (u: int) =
    forall j: int. 0 <= j < u -> i <> j -> a[i] <> a[j]

  predicate diff (a: array int) (i: int) =
    forall j: int. 0 <= j < a.length -> i <> j -> a[i] <> a[j]

  let function b_diff (a: array int) (i: int) : bool
    requires { 0 <= i < a.length }
    ensures { result <-> diff a i }
  =
    let n = a.length in
    for j = 0 to n - 1 do
      invariant { diff_sub a i j }
      if (a[j] = a[i] && j <> i) then return False
    done;
    True

  predicate inj_sub2 (a: array int) (u: int) =
    forall i: int. 0 <= i < u -> diff a i

  let function b_injective (a: array int) : bool
    ensures { result <-> injective a }
  =
    let n = a.length in
    for j = 0 to n - 1 do
      invariant { inj_sub2 a j }
      if not (b_diff a j) then return False
    done;
    True

  let function b_range (a: array int) : bool
    ensures { result <-> range a }
  =
    let n = a.length in
    for j = 0 to n - 1 do
      invariant { range_sub a 0 j n }
      if not (in_interval a[j] 0 n) then return False
    done;
    True

end


module ToList

  use int.Int
  use array.Array
  use array.ArrayEq
  use list.List

  let rec function to_list (a: array int) (l u: int) : list int
    requires { l >= 0 /\ u <= a.length }
    variant  { u - l }
  = if u <= l then Nil else Cons a[l] (to_list a (l+1) u)

end


module ArrayCte

  use int.Int
  use array.Array

  predicate cte_sub (a: array int) (l u b: int) =
    forall i:int. l <= i < u -> a[i] = b

  predicate cte (a: array int) (b: int) = cte_sub a 0 a.length b

end


module ArrayId

  use int.Int
  use array.Array

  predicate is_id_sub (a: array int) (l u: int) =
    forall i:int. l <= i < u -> a[i] = i

  predicate is_id (a: array int) = is_id_sub a 0 a.length

end


module ArrayInc

  use int.Int
  use array.Array

  predicate is_inc_sub (a: array int) (l u: int) =
    forall i j:int. l <= i < j < u -> a[i] < a[j]

  predicate is_inc (a: array int) = is_inc_sub a 0 a.length

  let function b_inc (a: array int) : bool
    ensures { result <-> is_inc a }
  =
    let n = a.length in
    for i = 1 to n-1 do
      invariant { is_inc_sub a 0 i }
      if not (a[i-1] < a[i]) then return False
    done;
    True

end


module ArrayDec

  use int.Int
  use array.Array

  predicate is_dec_sub (a: array int) (l u:int) =
    forall i j:int. l <= i < j < u -> a[j] < a[i]

  predicate is_dec (a: array int) = is_dec_sub a 0 a.length

end


(* From lex.mlw: *)

(** Lexicographic order *)

module Lex

  use int.Int
  use array.Array
  use array.ArrayEq

  (** * Equality of initial sub-arrays a1[0..u-1] and a2[0..u-1] *)

  predicate eq_prefix (a1 a2: array int) (u: int) = array_eq_sub a1 a2 0 u

  (** * Lexicographic order on arrays of integers *)

  (** ** Strict order *)

  predicate lt_lex_sub_at (a1 a2:array int) (l u:int) (i:int) = l <= i < u
    /\ array_eq_sub a1 a2 l i /\ a1[i] < a2[i]

  predicate lt_lex_at (a1 a2: array int) (i:int) = a1.length = a2.length
    /\ lt_lex_sub_at a1 a2 0 a1.length i

  predicate lt_lex_sub (a1 a2: array int) (l u: int) = exists i:int.
    lt_lex_sub_at a1 a2 l u i

  predicate lt_lex (a1 a2: array int) = a1.length = a2.length
    /\ lt_lex_sub a1 a2 0 a1.length

  predicate le_lex_sub (a1 a2: array int) (l u: int) = lt_lex_sub a1 a2 l u
    \/ array_eq_sub a1 a2 l u

  predicate le_lex (a1 a2: array int) = a1.length = a2.length /\ le_lex_sub a1 a2 0 a1.length

  (* For the generator of permutations: *)
  lemma prefix_le_lex_sub: forall a b:array int, l u:int.
    eq_prefix a b l /\ le_lex_sub a b l u -> le_lex_sub a b 0 u

  let rec lemma not_array_eq_sub (a b: array int) (l u: int) : unit
    requires { 0 <= l < u <= a.length = b.length }
    requires { not (array_eq_sub a b l u) }
    variant  { u - l }
    ensures  { exists i:int. l <= i < u /\ array_eq_sub a b l i /\ a[i] <> b[i] }
  =
    if a[l] = b[l] then not_array_eq_sub a b (l+1) u

  lemma total_order: forall a b: array int, l u: int.
     0 <= l < u <= a.length = b.length /\ not (lt_lex_sub b a l u)
     -> le_lex_sub a b l u

end


(* From lexList.mlw *)

module LexList

  use int.Int
  use list.List
  use list.Length
  use list.NthNoOpt

  let rec predicate list_eq (l1 l2: list int) =
    length l1 = length l2 &&
    match l1 with 
    | Nil ->
       match l2 with
       | Nil -> true
       | _ -> false
       end
    | Cons x1 r1 ->
      match l2 with 
      | Nil -> false
      | Cons x2 r2 -> x1 = x2 && list_eq r1 r2
      end 
    end

  lemma list_eq_cons: 
    forall l1 l2: list int, x1 x2: int.
      list_eq (Cons x1 l1) (Cons x2 l2) <-> list_eq l1 l2 /\ x1 = x2
  
  let rec predicate lt_lex (l1 l2: list int) =
    length l1 = length l2 &&
    match l1 with
    | Nil -> 
      match l2 with
      | Nil -> false        (* if `l1` and `l2` are `Nil` *)
      | _ -> true
      end
    | Cons x1 r1 ->
      match l2 with
      | Nil -> false
      | Cons x2 r2 -> x1 < x2 || (x1 = x2 && lt_lex r1 r2)
      end
    end

  lemma l_lt_lex: 
    forall l1 l2: list int, x1 x2: int.
      length l1 = length l2 /\ x1 < x2 -> lt_lex (Cons x1 l1) (Cons x2 l2)
  
  predicate le_lex (l1 l2: list int) = lt_lex l1 l2 \/ list_eq l1 l2  

  lemma l_le_lex:
    forall l1 l2: list int, x1 x2: int.  
      ((list_eq (Cons x1 l1) (Cons x2 l2) <-> list_eq l1 l2) /\ x1 = x2) \/
      (length l1 = length l2 /\ x1 < x2 -> lt_lex (Cons x1 l1) (Cons x2 l2))

  let rec lemma total_order (l1 l2: list int) : bool
    requires { length l1 = length l2 }
    requires { le_lex l1 l2 \/ lt_lex l2 l1 }
    variant { l1 }
    ensures { result }
  =
    match l1 with
      | Nil -> 
        match l2 with
        | Nil -> true
        | _   -> false
        end
      | Cons x1 r1 -> 
        match l2 with
        | Nil -> false
        | Cons x2 r2 -> 
            if (x1 <= x2 || x2 < x1) 
            then true
            else total_order r1 r2
        end
        
    end

end


(* From listExtension.mlw: *)

(* Extensions of stdlib/list.mlw *)

module ListLengthExtension

  use int.Int
  use list.List
  use list.Length

   (* Two lemmas for Coq proofs of lemmas in subsequent modules. *)

  lemma Length_cons : forall x:'a, l:list 'a. length (Cons x l) = 1 + length l
  lemma Length_cons_pos:  forall x:'a, l:list 'a. length (Cons x l) > 0
  
end


module ListExtension

  use int.Int
  use ref.Ref
  use list.List
  use list.Length
  use list.Append
  use list.NthNoOpt
  use list.Mem
  use ListLengthExtension
  use option.Option

  (* For shorter Coq proofs. Proved with Alt-Ergo. *)
  lemma Length_not_nil: forall l: list 'a. length l > 0 <-> l <> Nil

  predicate is_blist (l:list int) (b:int) = forall i:int.
    0 <= i < length l -> 0 <= nth i l < b

  (* (is_ipj l i) holds iff l is [i; i+1; ...] *)
  predicate is_ipj (l:list int) (i: int) = forall j:int.
    0 <= j < length l -> nth j l = i + j

  (* (is_id l) holds iff l is [0; 1; ...; n-1] with n = length l. *)
  predicate is_id (l:list int) = forall i:int.
    0 <= i < length l -> nth i l = i

  (* (id_aux n i) is the list [i; i+1; ...; n-1] *)
  let rec id_aux (n i: int) : list int
    requires { 0 <= n }
    ensures  { length result = n }
    ensures  { is_ipj result i }
    variant  { n }
  =
    if n <= 0 then Nil else Cons i (id_aux (n-1) (i+1))

  (* (id n) is the list [0; 1; ...; n-1] *)
  let id (n: int) : list int
    requires { 0 <= n }
    ensures  { length result = n }
    ensures  { is_id result }
  =
    id_aux n 0

  let rec rm_nth (x:int) (l:ref (list int)) : int
    requires { 0 <= x < length !l }
    ensures  { result = nth x (old !l) }
    ensures  { forall i. 0 <= i < x -> nth i !l = nth i (old !l) }
    ensures  { forall i. x <= i < length !l -> nth i !l = nth (i+1) (old !l) }
    ensures  { length !l = length (old !l) - 1 }
    variant  { length !l }
  =
    match (!l) with
    | Nil -> l := Nil; 0
    | Cons y m ->
        if x = 0 then begin
          l := m; y
        end else begin
          let r = ref m in
          let z = rm_nth (x-1) r in
          l := Cons y !r;
          z
        end
    end

  (* `(make n v)` creates the list of size `n` containing only `v`. *)
  (*  Similar to function `make` for arrays in stdlib.              *)
  
  let rec function make (n v: int) : list int
    variant { n }
    requires { n >= 0 }
    ensures { result.length = n }
    ensures { forall i. 0 <= i < n -> nth i result = v }
  =
    if n = 0 then Nil else Cons v (make (n-1) v)

  let rec nth_func_rec (i: int) (l: list int) : int
    variant { i }
    requires { 0 <= i < length l }
    ensures { result = nth i l }
  = 
    match 
      l with Cons x r -> if i = 0 then x else nth_func_rec (i-1) r
    end 
    
  let predicate in_interval (x l u: int) = l <= x < u

  predicate range_sub (a: list int) (l u b: int) = forall i: int.
    l <= i < u -> in_interval (nth i a) 0 b

end


module ArrayList

  use int.Int
  use array.Array
  use array.ToList
  use list.List
  use list.Length as L
  use list.NthNoOpt

  predicate to_array_p_sub (m: list 'a) (a: array 'a) (l u: int) =
   a.length = L.length m /\
   forall i: int. l <= i < u -> nth i m = a[i]

  predicate to_array_p (l: list 'a) (a: array 'a) =
   a.length = L.length l /\
   forall i: int. 0 <= i < a.length -> nth i l = a[i]
     
  let rec to_array_rec (l: list int) (a: array int) : unit
    requires { L.length l <= a.length }
    variant { L.length l }
    ensures { L.length l <= a.length }
  =
    match l with
    | Nil -> ()
    | Cons y m -> a[a.length - L.length l] <- y; to_array_rec m a
    end

  let function to_array (l: list int) : array int
    requires { L.length l >= 0 }
    ensures { L.length l = result.length }
  =
    let a = make (L.length l) 0 in
    to_array_rec l a;
    a
    
  predicate to_list_p (a: array int) (l: list int) =
     a.length = L.length l /\
     forall i: int. 0 <= i < (a.length) -> nth i l = a[i]

  (** Proved with CVC4 1.6 *)
  lemma bijection_array_list:
    forall a: array int, l: list int.
    to_array_p l a <-> to_list_p a l 
    
end


module ListCte

  use int.Int
  use list.List
  use list.Length
  use list.NthNoOpt

  predicate cte_sub (a: list int) (l u b: int) =
    forall i:int. l <= i < u -> nth i a = b

  predicate cte (a: list int) (b: int) = cte_sub a 0 (length a) b

end


module ListEq

  use int.Int
  use list.List
  use list.Length
  use list.NthNoOpt

  predicate list_eq_sub (a1 a2: list 'a) (l u: int) =
    length a1 = length a2 /\ 0 <= l <= length a1 /\ 0 <= u <= length a1 /\
    forall i: int. l <= i < u -> nth i a1 = nth i a2

  predicate list_eq (a1 a2: list 'a) =
    length a1 = length a2 /\ list_eq_sub a1 a2 0 (length a1)

end


(* From mapExtension.mlw: *)

(* Extensions of stdlib/map.mlw *)

module MapExtension

  use int.Int
  use map.Map
  use map.Occ
  use map.MapPermut

(* Pb: Automated provers do not instantiate correctly this lemma from map.mlw:
  lemma occ_append:
    forall v: 'a, m: map int 'a, l mid u: int.
    l <= mid <= u -> occ v m l u = occ v m l mid + occ v m mid u
    (* by induction on u *)
*)

  (* Instance of Lemma occ_append to help the automated provers.
     Easily proved by Alt-Ergo, Z3 and CVC4. *)
  lemma occ_append_instance:
    forall v: 'a, m: map int 'a, mid u: int.
    0 <= mid <= u -> occ v m 0 u = occ v m 0 mid + occ v m mid u

  lemma permut_split: forall a b: map int 'a, l i u: int.
    l <= i < u -> permut a b l u -> permut a b l i
    -> permut a b i u

end


(* From generator/lexgen.mlw: *)

module Cursor

  use int.Int
  use array.Array

  type cursor = {
        current: array int; (* current array *)
    mutable new: bool;      (* true iff current is a new array *)
  }

end


(** {1 Refinement of lexicographic order} *)

module LexXX

  use int.Int
  use array.Array
  use export Lex
  use Cursor

  predicate is_XX (a: array int)

  (* a is the smallest XX in lexicographic order *)
  predicate min_lex (a: array int) = forall b: array int.
    a.length = b.length /\ is_XX b -> le_lex_sub a b 0 a.length

  (* a is the largest XX in lexicographic order *)
  predicate max_lex (a: array int) = forall b: array int.
    a.length = b.length /\ is_XX b -> le_lex_sub b a 0 a.length

  (* (inc a1 a2) holds iff a2 is the smallest array larger than a1 *)
  predicate inc (a1 a2: array int) = a1.length = a2.length /\
    lt_lex_sub a1 a2 0 a1.length /\ forall a3: array int. a3.length = a1.length /\
    is_XX a3 /\ lt_lex_sub a1 a3 0 a1.length
    -> le_lex_sub a2 a3 0 a1.length

  predicate sound (c: cursor) = is_XX c.current

end


(** {1 Refinement of lexicographic order with an integer parameter} *)

module LexIntXX

  use int.Int
  use array.Array
  use export Lex
  use Cursor

  predicate is_XX (a: array int) (k: int)

  (* a is the smallest XX in lexicographic order *)
  predicate min_lex (a: array int) (k: int) = forall b: array int.
    a.length = b.length /\ is_XX b k -> le_lex_sub a b 0 a.length

  (* a is the largest XX in lexicographic order *)
  predicate max_lex (a: array int) (k: int) = forall b: array int.
    a.length = b.length /\ is_XX b k -> le_lex_sub b a 0 a.length

  (* (inc a1 a2) holds iff a2 is the smallest array larger than a1 *)
  predicate inc (a1 a2: array int) (k: int) = a1.length = a2.length /\
    is_XX a1 k /\ is_XX a2 k /\
    lt_lex_sub a1 a2 0 a1.length /\ forall a3: array int. a3.length = a1.length /\
    is_XX a3 k /\ lt_lex_sub a1 a3 0 a1.length
    -> le_lex_sub a2 a3 0 a1.length

  predicate sound (c: cursor) (k: int) = is_XX c.current k

end


(** {2 Generic definition of a lexicographic small step generator}

   With a generic function small_check for BET. *)

module SmallCheck

  use option.Option
  use int.Int
  use ref.Ref
  use array.Array
  use export Lex
  use ToList as AE
  use list.List
  use list.Length as L
  use Cursor
  use export ArrayList

  predicate is_XXX (a: array int)

  clone export LexXX with
    predicate is_XX = is_XXX

  val create_cursor (n: int) : cursor
    requires { n >= 0 }
    ensures  { result.new -> sound result }
  val next (c: cursor) : unit
    writes   { c.current, c.new }
    requires { sound c }
    ensures  { c.new -> sound c }

  (* Type for BET output *)
  type verdict = {
    witness: option (list int); (* Some counterexample, or None if test passes *)
    rank: int;         (* number of tested data when witness is found,
                          or total number of tested data if no counterexample *)
  }

  let small_check (oracle: list int -> bool) (n: int) : verdict
    requires { n >= 0 }
    diverges
  =
    let c = create_cursor n in
    let ref r = 0 in
    while c.new do
      invariant { c.new -> sound c }
      r := r+1;
      let a = c.current in
      let l = AE.to_list a 0 a.length in
      if oracle l then
        next c
      else
        return { witness = Some l; rank = r }
    done;
    { witness = None; rank = r }

end


(** {BET for data with type (array int) and an oracle with 
     type (list int -> int -> bool), additional integer parameter} *)

module SmallCheckInt

  use option.Option
  use int.Int
  use ref.Ref
  use array.Array
  use export Lex
  use array.ToList
  use list.List
  use list.Length as L
  use Cursor
  use export ArrayList

  predicate is_XXX (a: array int) (k: int)

  clone export LexIntXX with
    predicate is_XX = is_XXX

  val create_cursor (n: int) (k: int) : cursor
    requires { n >= 0 }
    ensures { result.new -> sound result k }

  val next (c: cursor) (k: int) : unit
    writes   { c.current, c.new }
    requires { sound c k }
    ensures  { c.new -> sound c k }

  (* Type for BET output *)
  type verdict = {
    witness: option (list int); (* Some counterexample, or None if test passes *)
    rank: int;         (* number of tested data when witness is found,
                          or total number of tested data if no counterexample *)
  }

  let small_check_int (oracle: list int -> int -> bool) (n k: int) : verdict
    requires { n >= 0 }
    diverges
  =
    let c = create_cursor n k in
    let ref r = 0 in
    while c.new do
      invariant { c.new -> sound c k }
      r := r+1;
      let a = c.current in
      let l = to_list a 0 a.length in
      if oracle l k then
        next c k
      else
        return { witness = Some l; rank = r }
    done;
    { witness = None; rank = r }

end


(** {Generic definition of a lexicographic small step generator by filtering} *)

module Filter

  use int.Int
  use array.Array
  use Array as A (* for copy *)
  use Lex
  use Cursor

  predicate is_X (a: array int)
  predicate is_Y (a: array int)
  predicate is_Z (a: array int) = is_X a /\ is_Y a

  val b_Y (a: array int) : bool
    ensures { result <-> is_Y a }

  clone LexXX as LX with
    predicate is_XX = is_X  (* LX.min_lex, LX.max_lex, LX.inc and LX.sound for is_X *)

  clone LexXX as LZ with
    predicate is_XX = is_Z  (* LZ.min_lex, LZ.max_lex, LZ.inc and LZ.sound for is_Z *)

  val create_cursor_X (n: int) : cursor
    requires { n >= 0 }
    ensures  { result.new -> LX.sound result }
    ensures  { result.new -> LX.min_lex result.current }

  val next_X (c: cursor) : unit
    writes   { c.current, c.new }
    requires { LX.sound c }
    ensures  { c.new -> LX.sound c }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> LX.inc (old c.current) c.current }
    ensures  { not c.new -> LX.max_lex (old c.current) }

  let create_cursor (n: int) : cursor
    diverges
    requires { n >= 0 }
    ensures  { result.new -> LZ.sound result }
    (* DIFFICULT: ensures  { result.new -> LZ.min_lex result.current } *)
  =
    let c = create_cursor_X n in
    while c.new && not (b_Y c.current) do
      invariant { c.new -> LX.sound c }
      next_X c
    done;
    c

  let next (c: cursor) : unit
    diverges
    writes   { c.current, c.new }
    requires { c.new }
    requires { LZ.sound c }
    ensures  { c.new -> LZ.sound c }
(*
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> LZ.inc (old c.current) c.current }
    ensures  { not c.new -> LZ.max_lex (old c.current) }
*)
  =
    let a = make c.current.length 0 in    (* a may be the last array satisfying is_Z *)
    A.copy c.current a;
    if c.new then next_X c;
    while c.new && not (b_Y c.current) do
      invariant { c.new -> LX.sound c }
      next_X c
    done;
    (* Here, there is no new X array, or none of the new X arrays satisfies is_Z. *)
    if not (b_Y c.current) then begin (* a was really the last array satisfying is_Z *)
      A.copy a c.current;  (* a is restored in c *)
      c.new <- False       (* and is marked as not new, i.e. already visited *)
    end;

end


module FilterInt

  use int.Int
  use array.Array
  use Array as A (* for copy *)
  use Lex
  use Cursor

  predicate is_X (a: array int) (k: int)
  predicate is_Y (a: array int) (k: int)
  predicate is_Z (a: array int) (k: int) = is_X a k /\ is_Y a k

  val b_Y (a: array int) (k: int) : bool
    ensures { result <-> is_Y a k }

  clone LexIntXX as LX with
    predicate is_XX = is_X  (* LX.min_lex, LX.max_lex, LX.inc and LX.sound for is_X *)

  clone LexIntXX as LZ with
    predicate is_XX = is_Z  (* LZ.min_lex, LZ.max_lex, LZ.inc and LZ.sound for is_Z *)

  val create_cursor_X (n k: int) : cursor
    requires { n >= 0 }
    ensures  { result.new -> LX.sound result k }
    ensures  { result.new -> LX.min_lex result.current k }

  val next_X (c: cursor) (k: int) : unit
    writes   { c.current, c.new }
    requires { LX.sound c k }
    ensures  { c.new -> LX.sound c k }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> LX.inc (old c.current) c.current k }
    ensures  { not c.new -> LX.max_lex (old c.current) k }

  let create_cursor (n k: int): cursor
    diverges
    requires { n >= 0 }
    ensures  { result.new -> LZ.sound result k }
(*
    ensures  { result.new -> LZ.min_lex result.current k }
*)
  =
    let c = create_cursor_X n k in
    while c.new && not (b_Y c.current k) do
      invariant { c.new -> LX.sound c k }
      next_X c k
    done;
    c

  let next (c: cursor) (k: int) : unit
    diverges
    writes   { c.current, c.new }
    requires { c.new }
    requires { LZ.sound c k }
    ensures  { c.new -> LZ.sound c k }
(*
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> LZ.inc (old c.current) c.current k }
    ensures  { not c.new -> LZ.max_lex (old c.current) k }
*)
  =
    let a = make c.current.length 0 in    (* a may be the last array satisfying is_Z *)
    A.copy c.current a;
    if c.new then next_X c k;
    while c.new && not (b_Y c.current k) do
      invariant { c.new -> LX.sound c k }
      next_X c k
    done;
    (* Here, there is no new X array, or none of the new X arrays satisfies is_Z. *)
    if not (b_Y c.current k) then begin (* a was really the last array satisfying is_Z *)
      A.copy a c.current;  (* a is restored in c *)
      c.new <- False       (* and is marked as not new, i.e. already visited *)
    end;

end


(* From generator/lexgenList.mlw: *)

module CursorList

  use int.Int
  use list.List

  type cursor = {
    mutable current: list int;  (* current list *)
    mutable new: bool;          (* true iff current is a new list *)
  }

end


(** {1 Refinement of lexicographic order with an integer parameter} *)

module LexIntXXList

  use int.Int
  use list.List
  use list.Length
  use export LexList
  use CursorList

  predicate is_XX (l: list int) (k: int)

  (* `l` is the smallest XX in lexicographic order *)
  predicate min_lex (l: list int) (k: int) = forall m: list int.
    length l = length m -> is_XX m k -> le_lex l m  
   
  (* `l` is the largest XX in lexicographic order *)
  predicate max_lex (l: list int) (k: int) = forall m: list int.
    length l = length m /\ is_XX m k -> le_lex m l

  (* `inc a1 a2` holds iff `a2` is the smallest array larger than `a1` *)
  predicate inc (a1 a2: list int) (k: int) = (length a1) = (length a2) /\
    is_XX a1 k /\ is_XX a2 k /\
    lt_lex a1 a2 /\ forall a3: list int. (length a3) = (length a1) /\
    is_XX a3 k /\ lt_lex a1 a3
    -> le_lex a2 a3

  predicate sound (c: cursor) (k: int) = is_XX c.current k

end


(* {2 Enumerative testing for data with type (list int) and an oracle with 
  type list int -> bool} *)

module SmallCheckIntList

  use option.Option
  use int.Int
  use ref.Ref
  use export LexList
  use list.List
  use list.Length as L
  use CursorList

  predicate is_XXX (l: list int) (k: int)

  clone export LexIntXXList with
    predicate is_XX = is_XXX

  val create_cursor (n: int) (k: int) : cursor
    requires { n >= 0 }
    ensures  { result.new -> sound result k }

  val next (c: cursor) (k: int) : unit
    writes   { c.current, c.new }
    requires { sound c k }
    ensures  { c.new -> sound c k }

  (* Type for BET output *)
  type verdict = {
    witness: option (list int); 
    rank: int;

  }

  let small_check_int (oracle: list int -> int -> bool) (n k: int) : verdict
    requires { n >= 0 }
    diverges
  =
    let c = create_cursor n k in
    let ref r = 0 in
    while c.new do
      invariant { c.new -> sound c k }
      r := r+1;
      let l = c.current in
      if oracle l k then
        next c k
      else
        return { witness = Some l; rank = r }
    done;
    { witness = None; rank = r }

end


(* From generator/barray/Barray.mlw: *)

(* A barray is an array of integers with values in [0..b-1] for some bound b. *)

module Barray

  use int.Int
  use array.Array
  use ArrayInjection
  use Lex

  predicate is_barray_sub (a: array int) (l u b: int) = range_sub a l u b

  predicate is_barray (a: array int) (b: int) = is_barray_sub a 0 a.length b

  let function b_barray (a: array int) (b: int) : bool
    ensures { result <-> is_barray a b }
  =
    for i = 0 to a.length-1 do
      invariant { is_barray_sub a 0 i b }
      if not (0 <= a[i] < b) then return False
    done;
    True

end

(** {Enumeration of barrays} *)

module BarrayEnum

  use int.Int
  use ref.Ref
  use array.Array
  use array.ArrayEq
  use ArrayCte
  use Barray
  use Cursor

  clone export LexIntXX with
    predicate is_XX = is_barray

  let create_cursor (n b: int) : cursor
    requires { n >= 0 }
    ensures  { result.new -> sound result b }
    ensures  { result.new -> min_lex result.current b }
    ensures  { length result.current = n }
  =
    let a = make n 0 in
    if b <= 0 then
      { current = a; new = False }
    else
      { current = a; new = True }

  let next (c: cursor) (b: int) : unit
    writes   { c.current, c.new }
    requires { sound c b }
    ensures  { sound c b }
    ensures  { c.current.length = (old c).current.length }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> inc (old c.current) c.current b }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex (old c.current) b }
    ensures  { not c.new -> max_lex c.current b }
  =
    if b <= 0 then
      c.new <- False
    else
      let a = c.current in
      let n = a.length in
      label L in 
      let ref r = (n-1) in
      while r >= 0 && a[r] = b-1 do
        invariant { -1 <= r <= n-1 }
        invariant { cte_sub a (r+1) n (b-1) }
        variant   { r + 1 }
        r := r - 1
      done;
      if (r < 0) then (* Last array reached. *)
        c.new <- False
      else begin
       a[r] <- a[r] + 1;
       for i = r+1 to n-1 do
         invariant { r+1 <= i <= n }
         invariant { (a at L)[r]+1 = a[r] }
         invariant { cte_sub a (r+1) i 0 }
         invariant { lt_lex_at (a at L) a r }
         a[i] <- 0
       done;
       c.new <- True
       end

end


(* From generator/blist/Blist.mlw: *)

module Blist

  use int.Int
  use list.List
  use list.Length
  use list.Nth
  use option.Option
  use bool.Bool
  use ListExtension

  predicate is_blist_sub (a: list int) (l u b: int) = 0 < b /\ range_sub a l u b

  let rec predicate is_blist (l: list int) (b: int) : bool
  =
    match l with
    | Nil -> true
    | Cons x r -> 0 <= x < b && is_blist r b
    end

end


(** {Enumeration of blist} *)

module BlistEnum

  use int.Int
  use ref.Ref
  use list.List
  use list.Length
  use list.NthNoOpt
  use option.Option
  use bool.Bool
  use ListExtension
  use ListEq
  use ListCte
  use Blist
  use CursorList

  clone export LexIntXXList with
    predicate is_XX = is_blist

  let create_cursor (n b: int) : cursor
    requires { n >= 0 }
    ensures  { result.new -> sound result b }
    ensures  { length result.current = n }
  =
    let l = make n 0 in
    if b < 0 
    then { current = l; new = False }
    else
      if is_blist l b
        then { current = l; new = True }
        else { current = l; new = False }

  let rec next_blist_rec (l: list int) (b: int) : option (list int)
    variant  { length l }
    requires { is_blist l b }
    ensures  { match result with None -> True | Some l -> is_blist l b end }
    ensures  { match result with None -> True | Some r -> lt_lex l r end }
   =
     match l with
     | Nil -> None
     | Cons x r ->
        if x < b-1 then
          Some (Cons (x+1) r)
        else
          match next_blist_rec r b with
          | None -> None
          | Some m -> Some (Cons x m)
          end
     end

  let next (c: cursor) (b: int) : unit
     writes   { c.current, c.new }
     requires { sound c b }
     ensures  { sound c b }
     ensures  { c.current.length = (old c).current.length }
     ensures  { c.new -> lt_lex (old c.current) c.current }
   =
     if b < 0 
       then c.new <- False
       else
     match next_blist_rec c.current b with
     | None -> c.new <- False
     | Some l ->
         c.current <- l;
         c.new <- True
     end

end


(* From generator/endo/Endo.mlw: *)

module Endo

  use int.Int
  use array.Array

  predicate is_endo_sub (a:array int) (l u:int) = forall i:int.
    l <= i < u -> 0 <= a[i] < a.length

  predicate is_endo (a:array int) = is_endo_sub a 0 a.length

  let function b_endo (a: array int) : bool
    ensures { result <-> is_endo a }
  =
    let n = a.length in
    for i = 0 to n-1 do
      invariant { is_endo_sub a 0 i }
      if not (0 <= a[i] < n) then return False
    done;
    True

  lemma b_is_endo_sound: forall a: array int. is_endo a -> b_endo a = true

  (* Wrong mutation of b_endo: *)
  let function b_endo_wrong (a: array int) : bool
    ensures { result <-> is_endo a }
  =
    let n = a.length in
    for i = 0 to n-1 do
      invariant { is_endo_sub a 0 i }
      if not (0 <= a[i] < n-1) then return False;
    done;
    True

   (* Wrong lemma, however proved as a consequence of the wrong postcondition
      of b_endo_wrong. *)
  lemma b_endo_wrong_sound:
    forall a: array int. is_endo a -> b_endo_wrong a = true

end


module EndoEnum

  use int.Int
  use ref.Ref
  use array.Array
  use array.ArrayEq
  use ArrayCte
  use Endo
  use Cursor

  clone LexXX with
    predicate is_XX = is_endo

  let create_cursor (n: int) : cursor
    ensures  { result.new = True <-> n >= 0 }
    ensures  { result.new = True <-> exists a : array int. length a = n /\ is_endo a }
    ensures  { result.new -> sound result }
    ensures  { result.new -> min_lex result.current }
    ensures  { result.new -> length result.current = n }
  =
    if n < 0 then
      { current = make 0 0; new = False }
    else
      let a = make n 0 in
      { current = a; new = True }

  let next (c: cursor) : unit
    requires { sound c }
    ensures  { sound c }
    ensures  { c.current.length = (old c).current.length }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> inc (old c.current) c.current }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex c.current }
  =
    let a = c.current in
    let n = a.length in
    label L in
    let ref r = (n-1) in
    while r >= 0 && a[r] = n-1 do
      invariant { -1 <= r <= n-1 }
      invariant { cte_sub a (r+1) n (n-1) }
      variant   { r + 1 }
      r := r - 1
    done;
    if (r < 0) then (* Last array reached. *)
      c.new <- False
    else begin
      a[r] <- a[r] + 1;
      for i = r+1 to n-1 do
        invariant { r+1 <= i <= n }
        invariant { (a at L)[r]+1 = a[r] }
        invariant { cte_sub a (r+1) i 0 }
        invariant { lt_lex_at (a at L) a r }
        a[i] <- 0
      done;
      c.new <- True
    end

end


(* From generator/fact/Fact.mlw: *)

module Fact

  use int.Int
  use array.Array

  predicate is_fact_sub (a:array int) (l u:int) = 
    forall i:int. l <= i < u -> 0 <= a[i] <= i
    
  predicate is_fact (a:array int) = is_fact_sub a 0 a.length

  let function b_fact (a: array int) : bool
    ensures { result <-> is_fact a }
  =
    let n = a.length in
    for i = 0 to n - 1 do
      invariant { is_fact_sub a 0 i }
      if not (0 <= a[i] <= i) then return False
    done;
    True

end


module FactEnum

  use int.Int
  use ref.Ref
  use array.Array
   use array.ArrayEq
  use ArrayCte
  use ArrayId
  use Fact
  use Cursor
  
  clone export LexXX with
    predicate is_XX = is_fact

  let create_cursor (n: int) : cursor
    requires { n >= 0 }
    ensures  { length result.current = n }
    ensures  { sound result }
    ensures  { min_lex result.current }
  = 
    let a = make n 0 in
    { current = a; new = True }

  let next (c: cursor) : unit
    requires { sound c }
    ensures  { sound c }
    ensures  { c.current.length = (old c).current.length }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> inc (old c.current) c.current }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex c.current }
  =
    let a = c.current in
    let n = a.length in
    label L in
    let ref r = n-1 in
    while r >= 0 && a[r] = r do
      invariant { -1 <= r <= n-1 }
      invariant { is_id_sub a (r+1) n }
      variant   { r + 1 }
      r := r - 1
    done; 
    if (r < 0) then (* Last array reached. *)
      c.new <- false
    else begin
      a[r] <- a[r] + 1;
      for i = r+1 to n-1 do
        invariant { r+1 <= i <= n }
        invariant { (a at L)[r]+1 = a[r] }
        invariant { cte_sub a (r+1) i 0 }
        invariant { lt_lex_at (a at L) a r }
        a[i] <- 0
      done;
      c.new <- True
    end
    
end


module FactEndo

  use Endo
  use EndoEnum as E
  use Fact

  clone export Filter with
    predicate is_X = is_endo,
    predicate is_Y = is_fact,
    val b_Y = b_fact,
    val create_cursor_X = E.create_cursor,
    val next_X = E.next

end


(* From generator/filtering/Filtering.mlw: *)

(* Injections: First example of a generator defined by filtering *)

module Inj

  use int.Int
  use array.Array
  use Barray
  use ArrayInjection

  predicate is_linear_sub (a: array int) (l: int) =
    forall i:int. 0 <= i < l -> diff a i

  predicate is_linear (a: array int) =
   forall i:int. 0 <= i < a.length -> diff a i

  let function b_linear (a: array int): bool
    ensures { result <-> is_linear a }
  =
    let n = a.length in
    for i = 0 to n-1 do
      invariant { is_linear_sub a i }
      if not (b_diff a i) then return False
    done;
    True

  predicate is_inj (a: array int) (k: int) =
   a.length <= k /\ is_barray a k /\ is_linear a

  let function b_injective (a: array int) (k: int): bool
    ensures { result <-> is_inj a k }
  =
    if k < a.length then
      False
    else
      b_barray a k && b_linear a

end


module InjBarray

  use Barray
  use BarrayEnum as E
  use Inj

  clone export FilterInt with
    predicate is_X = is_barray,
    predicate is_Y = is_inj,
    val b_Y = b_injective,
    val create_cursor_X = E.create_cursor,
    val next_X = E.next

end

(* Combinations: Second example of a generator defined by filtering *)

module Comb

  use int.Int
  use array.Array
  use Barray
  use ArrayInc

  predicate is_comb (a: array int) (k: int) =
     0 < k /\ is_barray a k /\ is_inc a

  let function b_comb (a: array int) (k: int): bool
    ensures { result <-> is_comb a k }
  =
    if k <= 0 then
      False
    else
      b_barray a k && b_inc a

end


module CombBarray

  use Barray
  use BarrayEnum as E
  use Comb

  clone export FilterInt with
    predicate is_X = is_barray,
    predicate is_Y = is_comb,
    val b_Y = b_comb,
    val create_cursor_X = E.create_cursor,
    val next_X = E.next

end


(* From generator/permutation/Permutation.mlw: *)

module Permutation

  use int.Int
  use array.Array
  use array.ArrayPermut
  use ArrayInjection
  use export ArrayInc
  use export ArrayDec
  use Lex

  predicate is_permut_sub (a:array int) (l u:int) =
    range_sub a l u u /\ inj_sub a l u

  predicate is_permut (a:array int) = range a /\ injective a

  let b_permutation (a:array int) : bool
    ensures { result <-> is_permut a }
  = 
    b_range a && b_injective a

  lemma endoinj_permut: forall a b: array int.
    0 <= a.length = b.length /\ is_permut a /\ is_permut b
    -> permut a b 0 a.length

  (* These two predicates specify that a[k] is the smallest value bigger than a[r] in
     the array a[r+1..a.length-1]: *)
  predicate im_sup1 (a: array int) (r k:int) = forall i:int. r < i < k -> a[k] < a[i]
  predicate im_sup2 (a: array int) (r k:int) = forall i:int. k < i < a.length -> a[i] < a[r]

  lemma min_lex_sub: forall a: array int, l u: int.
    0 <= l < u <= a.length /\ injective a /\ is_inc_sub a l u
    -> forall b:array int. permut a b l u /\ injective b
    -> le_lex_sub a b l u

  lemma max_lex_sub: forall a: array int, l u: int.
    0 <= l < u <= a.length /\ injective a /\ is_dec_sub a l u
    -> forall b:array int. permut a b l u /\ injective b
    -> le_lex_sub b a l u

end


module PermutationEnum

  use int.Int
  use int.EuclideanDivision
  use ref.Ref
  use array.Array
  use array.ArraySwap
  use array.ArrayExchange
  use array.ArrayPermut
  use array.ArrayEq
  use MapExtension
  use ArrayId
  use Permutation
  use Cursor

  clone LexXX with
    predicate is_XX = is_permut

  let create_cursor (n: int) : cursor
    requires { n >= 0 }
    ensures  { result.new && sound result }
    ensures  { min_lex result.current }
    ensures  { result.current.length = n }
  = 
    let a = make n 0 in
    for i = 0 to n-1 do
      invariant { 0 <= i <= n }
      invariant { is_id_sub a 0 i }
      a[i] <- i
    done;
    assert { is_id a };
    { current = a; new = True }

  (* The following lemmas are proved with SMT solvers and used as axioms in Coq: *)

  (* split permut *)
  lemma is_permut_split: forall a b: array int, l: int.
    0 <= l < a.length = b.length /\ is_permut a /\ is_permut b
    /\ permut a b 0 a.length /\ permut a b 0 l -> permut a b l a.length

  lemma is_permut_split_imply_permut_sub: forall a b: array int, l: int.
    0 <= l < a.length = b.length /\ is_permut a /\ is_permut b
    /\ permut a b 0 a.length /\ array_eq_sub a b 0 l -> permut_sub a b l a.length

  (* array_eq_sub implies permut in the same interval *)
  lemma array_eq_imply_permut: forall a b:array int, l u:int.
    0 <= l < u <= a.length = b.length
    /\ array_eq_sub a b l u -> permut a b l u

  (* permut and permut_sub are symmetric *)
  lemma permut_sym: forall a b:array int, l u: int.
    permut a b l u <-> permut b a l u

  lemma permut_sub_sym: forall a b:array int, l u: int.
    permut_sub a b l u <-> permut_sub b a l u

  lemma array_eq_sub_sym: forall a b: array int, l u: int.
    array_eq_sub a b l u <->  array_eq_sub b a l u

  (* permut is transitive *)
  lemma permut_trans: forall a1 a2 a3 : array int. forall l u : int.
    permut a1 a2 l u -> permut a2 a3 l u -> permut a1 a3 l u

  lemma permut_sub_trans: forall a1 a2 a3 : array int. forall l u : int.
    permut_sub a1 a2 l u -> permut_sub a2 a3 l u -> permut_sub a1 a3 l u

  (* array_eq_sub is transitive *)
  lemma array_eq_sub_trans: forall a1 a2 a3 : array int. forall l u : int.
    array_eq_sub a1 a2 l u -> array_eq_sub a2 a3 l u -> array_eq_sub a1 a3 l u

  (* Condition to find value b[l] on large or strict suffix if 
     (permut_sub a b l u) holds: *)
  lemma value_on_large_suffix: forall a b: array int, l u: int.
    0 <= l < u <= a.length = b.length /\ permut_sub a b l u
    -> exists i:int. l <= i < u /\ b[l] = a[i]

  lemma value_on_strict_suffix: forall a b: array int, l u: int.
    0 <= l < u <= a.length = b.length /\ permut_sub a b l u /\ lt_lex_sub_at a b l u l
    -> exists i:int. l < i < u /\ b[l] = a[i]

  (** Auxiliary lemma to prove inc_permut with Coq *)
  lemma array_eq_sub_trunc: forall a b: array int, l k u: int.
    0 <= l -> l <= k -> k < u -> u <= a.length -> a.length = b.length -> array_eq_sub a b l u 
    -> array_eq_sub a b l k

  lemma inc_permut: forall a b: array int, r j:int.
    0 <= r < j < a.length = b.length /\ is_permut a /\ is_dec_sub a (r+1) a.length /\
    is_permut b /\ is_inc_sub b (r+1) a.length /\
    lt_lex_at a b r /\ permut_sub a b r a.length /\
    im_sup1 a r j /\ im_sup2 a r j /\ b[r] = a[j]
    -> inc a b
    
  (** Proved with Coq and lemma `array_eq_sub_trunc`. *)

  predicate mirror (a b: array int) (k l u: int) = 
    forall i. l <= i < k <= u -> a[i] = b[u+l-1-i] /\ b[i] = a[u+l-1-i]

  let reverse (a: array int) (l u: int)
    requires { 0 <= l < u <= a.length }
    requires { is_permut_sub a l u }
    requires { is_dec_sub a l u }
    requires { is_permut a }
    ensures  { mirror a (old a) (div (l+u) 2) l u }
    ensures  { mirror a (old a) u l u }
    ensures  { is_permut_sub a l u }
    ensures  { is_inc_sub a l u }
    ensures  { array_eq_sub a (old a) 0 l }
    ensures  { array_eq_sub a (old a) u a.length }
    ensures  { permut_sub (old a) a l u }
    ensures  { permut_sub (old a) a 0 a.length }
    ensures  { is_permut a }
  =
    let m = div (l+u-1) 2 in
    for i = l to m do
      invariant { l <= i <= m+1 }
      invariant { mirror a (old a) i l u }
      invariant { array_eq_sub a (old a) i (u+l-i) }
      invariant { permut (old a) a l u }
      invariant { array_eq_sub (old a) a 0 l }
      invariant { array_eq_sub (old a) a u a.length }
      invariant { permut_sub (old a) a l u }
      swap a i (u+l-1-i);
    done

  let next (c: cursor) : unit
    requires { sound c }
    ensures  { sound c }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex c.current }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> inc (old c.current) c.current }
  =
    let a = c.current in
    let n = a.length in
    label L in
    if n <= 1 then
      c.new <- False
    else
      let ref r = (n-2) in (* 1. find the rightmost index r s.t. a[r] < a[r+1]: *)
      while r >= 0 && a[r] > a[r+1] do
        invariant { -1 <= r <= n-2 }
        invariant { is_dec_sub a (r+1) n }
        variant   { r + 1 }
        r := r - 1
      done;
      if r < 0 then (* last array reached. *)
        c.new <- False
      else (* 2. Find rightmost (i.e. smallest) element a[j] greater than a[r]: *)
        let ref j = (n-1) in
        while a[r] > a[j] do
          invariant { r + 1 <= j <= n-1 }
          invariant { im_sup2 a r j }
          variant   { j }
          j := j - 1
        done;
        swap a r j; (* 3. swap *)
        let _ = reverse a (r+1) n in (* 4. reverse suffix *)
        assert { lt_lex_at (a at L) a r };
        c.new <- True

end


(* From/generator/rgf/Rgf.mlw: *)

module Rgf

  use int.Int
  use array.Array

  predicate is_rgf_sub (a:array int) (l u: int) = a[0] = 0 /\
    forall i:int. l <= i < u -> 0 <= a[i] <= a[i-1]+1

  predicate is_rgf (a:array int) = a.length = 0 \/ is_rgf_sub a 1 a.length

  let function b_rgf (a: array int) : bool
    ensures { result <-> is_rgf a }
  =
    let n = a.length in
    if n = 0 then
      return True
    else
      if a[0] <> 0 then
        return False
      else
        for i = 1 to n-1 do
          invariant { is_rgf_sub a 1 i }
          if not (0 <= a[i] <= a[i-1]+1) then return False
        done;
        True

end


module RgfEnum

  use int.Int
  use ref.Ref
  use array.Array
  use array.ArrayEq
  use ArrayInc
  use ArrayCte
  use Rgf
  use Cursor

  clone LexXX with
    predicate is_XX = is_rgf

  let create_cursor (n: int) : cursor
    requires { n >= 0 }
    ensures  { sound result }
    ensures  { min_lex result.current }
    ensures  { length result.current = n }
  =
    let a = make n 0 in
    { current = a; new = True }

  let next (c: cursor) : unit
    writes   { c.current, c.new }
    requires { sound c }
    ensures  { sound c }
    ensures  { c.current.length = (old c).current.length }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> inc (old c.current) c.current }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex c.current }
  =
    let a = c.current in
    label L in
    let n = a.length in
    if n <= 1 then
      c.new <- False
    else
      let ref r = (n-1) in
      while r >= 1 && a[r] = a[r-1]+1 do
        invariant { 0 <= r <= n-1 }
        invariant { is_inc_sub a r n }
        variant   { r + 1 }
        r := r - 1
      done;
      if r = 0 then (* Last array reached. *)
        c.new <- False
      else begin
        a[r] <- a[r] + 1;
        for i = r+1 to n-1 do
          invariant { r+1 <= i <= n }
          invariant { lt_lex_sub_at (a at L) a 0 n r }
          invariant { cte_sub a (r+1) i 0 }
          invariant { (c.current at L)[r]+1 = c.current[r] }
          a[i] <- 0
        done;
        c.new <- True
      end

end

module RgfEndo

  use Endo
  use EndoEnum as E
  use Rgf

  clone export Filter with
    predicate is_X = is_endo,
    predicate is_Y = is_rgf,
    val b_Y = b_rgf,
    val create_cursor_X = E.create_cursor,
    val next_X = E.next

end


(* From generator/sorted/Sorted.mlw: *)

module Sorted

  use int.Int
  use array.Array
  use Barray

  predicate is_inc1_sub (a: array int) (l u:int) =
    forall i:int. l <= i < u -> a[i-1] <= a[i]

  predicate is_inc1 (a: array int) =
    forall i:int. 1 <= i < a.length -> a[i-1] <= a[i]

  predicate is_sorted (a: array int) (b: int) = is_barray a b /\ is_inc1 a

  let function b_inc1 (a: array int) : bool
    ensures { result <-> is_inc1 a }
  =
    let n = a.length in
    for i = 1 to n-1 do
      invariant { is_inc1_sub a 1 i }
      if not (a[i-1] <= a[i]) then return False
    done;
    True

  let function b_sorted (a: array int) (b: int) : bool
    ensures { result <-> is_sorted a b }
  =
    b_barray a b && b_inc1 a

end


module SortedEnum

  use int.Int
  use ref.Ref
  use array.Array
  use array.ArrayEq
  use ArrayCte
  use Sorted
  use Cursor

  clone LexIntXX with
    predicate is_XX = is_sorted

  let create_cursor (n k: int) : cursor
    requires { n >= 0 }
    ensures  { result.new -> sound result k }
    ensures  { result.new -> min_lex result.current k }
    ensures  { length result.current = n }
  = 
    let a = make n 0 in
    if k <= 0 then
      { current = a; new = False }
    else
      { current = a; new = True }

  let next (c: cursor) (k: int) : unit
    writes   { c.current, c.new }
    requires { sound c k }
    ensures  { sound c k }
    ensures  { c.current.length = (old c).current.length }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { c.new -> inc (old c.current) c.current k }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex (old c.current) k }
    ensures  { not c.new -> max_lex c.current k }
  =
    let a = c.current in
    label L in
    let n = a.length in
    let ref r = (n-1) in
    while r >= 0 && a[r] = k-1 do
      invariant { -1 <= r <= n-1 }
      invariant { cte_sub a (r+1) n (k-1) }
      variant   { r + 1 }
      r := r - 1
    done;
    if (r < 0) then (* Last array reached. *)
      c.new <- False
    else begin
      a[r] <- a[r] + 1;
      for i = r+1 to n-1 do
        invariant { r+1 <= i <= n }
        invariant { (a at L)[r]+1 = a[r] }
        invariant { cte_sub a (r+1) i a[r] }
        invariant { lt_lex_at (a at L) a r }
        a[i] <- a[r]
      done;
      c.new <- True
    end

end


module SortedBarray

  use Barray
  use BarrayEnum as E
  use Sorted

  clone export FilterInt with
    predicate is_X = is_barray,
    predicate is_Y = is_sorted,
    val b_Y = b_sorted,
    val create_cursor_X = E.create_cursor,
    val next_X = E.next

end


(* From generator/surj/Surj.mlw: *)

module Surj

  use int.Int
  use array.Array
  use Barray

  predicate pre_img_sub (a: array int) (u j: int) =
    exists i:int. 0 <= i < u /\ a[i] = j

  predicate pre_img (a: array int) (j: int) = (* pre_img_sub a a.length j *)
    exists i:int. 0 <= i < a.length /\ a[i] = j

  let function b_pre_img (a: array int) (j: int): bool
    ensures { result <-> pre_img a j }
  =
    for i = 0 to a.length-1 do
      invariant { not (pre_img_sub a i j) }
      if a[i] = j then return True
    done;
    false

  predicate init_pre_img (a: array int) (k: int) =
    forall j:int. 0 <= j < k -> pre_img a j

  let function b_init_pre_img (a: array int) (k: int): bool
    ensures { result <-> init_pre_img a k }
  =
    for j = 0 to k-1 do
      invariant { init_pre_img a j }
      if not (b_pre_img a j) then return false
    done;
    True

(* For free in SurjBarray:
  predicate is_surj (a: array int) (k: int) = 
    is_barray a k /\ init_pre_img a k
*)

end


module SurjBarray

  use Barray
  use BarrayEnum as E
  use Surj

  clone export FilterInt with
    predicate is_X = is_barray,
    predicate is_Y = init_pre_img,
    val b_Y = b_init_pre_img,
    val create_cursor_X = E.create_cursor,
    val next_X = E.next

end
