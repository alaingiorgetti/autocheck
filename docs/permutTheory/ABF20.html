<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<link rel="stylesheet" href="style.css" type="text/css">
<title>ABF20.html</title>
</head>
<body>
<p>why3doc index <a href="index.html">index</a></p>
<hr>
<div class="why3doc">
<h1>Formalization of [ABF20]</h1>

<p>[ABF20] Michael Albert, Mathilde Bouvel, and Valentin Féray. Two first-order logics of 
  permutations. Journal of Combinatorial Theory, Series A, 171:105158, April 2020.
  [https://arxiv.org/abs/1808.05459v2](https://arxiv.org/abs/1808.05459v2).</p>
<p>[Gio20] A. Giorgetti. Formalisation et vérification de théories de permutations.
  Research report RR-1715 (in French), UBFC (Université de Bourgogne Franche-Comté) and 
  FEMTO-ST, 17 pages, December 2020.
  [https://hal.archives-ouvertes.fr/hal-03033416](https://hal.archives-ouvertes.fr/hal-03033416).</p>
<p>[Gio21] A. Giorgetti. Théories de permutations avec Why3. In JFLA 2021, 8 pages,
  April 2021.
  [http://jfla.inria.fr/jfla2021.html](http://jfla.inria.fr/jfla2021.html).
</p>
<h2>1. Proposal of extension of relations.mlw in stdlib, for TOOB</h2>
<pre><span class="keyword1">module</span> <a name="Relation_">Relation</a>
  <span class="keyword1">type</span> t
  <span class="keyword1">type</span> <a name="u_21">u</a>
  <span class="keyword1">predicate</span> <a name="rel_22">rel</a> <a href="#t_20">t</a> <a href="#u_21">u</a>
<span class="keyword1">end</span>

<span class="keyword1">module</span> <a name="Determinism_">Determinism</a> <span class="comment">(* or PartialFunction *)</span>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Relation_">Relation</a>
  <span class="keyword1">axiom</span> <a name="Deter_27">Deter</a> : <span class="keyword1">forall</span> x:<a href="#t_20">t</a>. <span class="keyword1">forall</span> y z:<a href="#u_21">u</a>. <a href="#rel_22">rel</a> x y -&gt; <a href="#rel_22">rel</a> x z -&gt; y = z
<span class="keyword1">end</span>

<span class="keyword1">module</span> <a name="Functionality_">Functionality</a>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Determinism_">Determinism</a> <span class="keyword1">with</span> <span class="keyword1">axiom</span> <a href="#Deter_27">Deter</a>
  <span class="keyword1">axiom</span> <a name="Total_32">Total</a> : <span class="keyword1">forall</span> x:<a href="#t_20">t</a>. <span class="keyword1">exists</span> y:<a href="#u_21">u</a>. <a href="#rel_22">rel</a> x y
<span class="keyword1">end</span>

<span class="keyword1">module</span> <a name="Injectivity_">Injectivity</a>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Relation_">Relation</a>
  <span class="keyword1">axiom</span> <a name="Injec_37">Injec</a> : <span class="keyword1">forall</span> x y:<a href="#t_20">t</a>. <span class="keyword1">forall</span> a:<a href="#u_21">u</a>. <a href="#rel_22">rel</a> x a -&gt; <a href="#rel_22">rel</a> y a -&gt; x = y
<span class="keyword1">end</span>

<span class="keyword1">module</span> <a name="Surjectivity_">Surjectivity</a>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Relation_">Relation</a>
  <span class="keyword1">axiom</span> <a name="Surjec_42">Surjec</a> : <span class="keyword1">forall</span> y:<a href="#u_21">u</a>. <span class="keyword1">exists</span> x:<a href="#t_20">t</a>. <a href="#rel_22">rel</a> x y
<span class="keyword1">end</span>

<span class="keyword1">module</span> <a name="Bijectivity_">Bijectivity</a>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Functionality_">Functionality</a> <span class="keyword1">with</span> <span class="keyword1">axiom</span> <a href="#Deter_27">Deter</a>, <span class="keyword1">axiom</span> <a href="#Total_32">Total</a>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Injectivity_">Injectivity</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_20">t</a> = <a href="#t_20">t</a>, <span class="keyword1">type</span> <a href="#u_21">u</a> = <a href="#u_21">u</a>, <span class="keyword1">predicate</span> <a href="#rel_22">rel</a> = <a href="#rel_22">rel</a>, <span class="keyword1">axiom</span> <a href="#Injec_37">Injec</a>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Surjectivity_">Surjectivity</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_20">t</a> = <a href="#t_20">t</a>, <span class="keyword1">type</span> <a href="#u_21">u</a> = <a href="#u_21">u</a>, <span class="keyword1">predicate</span> <a href="#rel_22">rel</a> = <a href="#rel_22">rel</a>, <span class="keyword1">axiom</span> <a href="#Surjec_42">Surjec</a>
<span class="keyword1">end</span>

<span class="keyword1">module</span> <a name="MapRelation_">MapRelation</a>
  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>

  <span class="keyword1">type</span> <a name="t_55">t</a>
  <span class="keyword1">type</span> <a name="u_56">u</a>

  <span class="keyword1">predicate</span> <a name="map_rel_59">map_rel</a> (m: <a href="map.html#map_9">map</a> <a href="#t_55">t</a> <a href="#u_56">u</a>) (x:<a href="#t_55">t</a>) (y:<a href="#u_56">u</a>) = (m[x] = y)
</pre>
<div class="info"><p>Binary relation associated to any map, as its graph.</p>
</div><pre>  <span class="keyword1">constant</span> <a name="m_62">m</a>: <a href="map.html#map_9">map</a> <a href="#t_55">t</a> <a href="#u_56">u</a>
</pre>
<div class="info"><p>Let <code>m</code> be any map.</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="m_graph_65">m_graph</a> (x:<a href="#t_55">t</a>) (y:<a href="#u_56">u</a>) = <a href="#map_rel_59">map_rel</a> <a href="#m_62">m</a> x y
</pre>
<div class="info"><p>Let <code>m_graph</code> be its associated binary relation.</p>
</div><pre>  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Functionality_">Functionality</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_20">t</a> = <a href="#t_55">t</a>, <span class="keyword1">type</span> <a href="#u_21">u</a> = <a href="#u_56">u</a>, <span class="keyword1">predicate</span> <a href="#rel_22">rel</a> = <a href="#m_graph_65">m_graph</a>
</pre>
<div class="info"><p>The graph of any map is a deterministic and total binary relation.</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>2. Proposal of extension of map.mlw in stdlib, for <code>ModelTOOB</code> and other modules</h2>
<pre><span class="comment">(* Injectivity, surjectivity and bijectivity for any maps, more general than
   module `MapInjection` in map.mlw in stdlib. *)</span>
<span class="keyword1">module</span> <a name="MapInjSurjBij_">MapInjSurjBij</a>

  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>

  <span class="keyword1">predicate</span> <a name="injective_81">injective</a> (m: <a href="map.html#map_9">map</a> 'a 'b) = <span class="keyword1">forall</span> i j: 'a. m[i] = m[j] -&gt; i = j
</pre>
<div class="info"><p><code>injective m</code> is true when <code>m</code> is an injection</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="surjective_84">surjective</a> (m: <a href="map.html#map_9">map</a> 'a 'b) = <span class="keyword1">forall</span> j: 'b. <span class="keyword1">exists</span> i: 'a. m[i] = j
</pre>
<div class="info"><p><code>surjective m</code> is true when <code>m</code> is a surjection</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="bijective_87">bijective</a> (m: <a href="map.html#map_9">map</a> 'a 'b) = <a href="#injective_81">injective</a> m /\ <a href="#surjective_84">surjective</a> m

  <span class="comment">(* TODO: add more, by analogy with `MapInjection`. *)</span>

<span class="keyword1">end</span>

</pre>
<h2>3. Proposal of extension of int.mlw in stdlib</h2>
<pre><span class="keyword1">module</span> <a name="NumOfExt_">NumOfExt</a>

  <span class="keyword1">use</span> int.<a href="int.html#Int_">Int</a>
  <span class="keyword1">use</span> int.<a href="int.html#NumOf_">NumOf</a>

  <span class="keyword1">lemma</span> <a name="Numof_no_add_101">Numof_no_add</a>:
    <span class="keyword1">forall</span> p : int -&gt; bool, a b c: int.
    a <a href="int.html#infix%20%3C=_25">&lt;=</a> b <a href="int.html#infix%20%3C_21">&lt;</a> c -&gt; <span class="keyword1">not</span> p b -&gt; <a href="int.html#numof_317">numof</a> p a c = <a href="int.html#numof_317">numof</a> p a b <a href="int.html#infix%20+_19">+</a> <a href="int.html#numof_317">numof</a> p (b<a href="int.html#infix%20+_19">+</a>1) c
</pre>
<div class="info"><p>More general than <code>Numof_left_no_add</code> in the stdlib.</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>4. Type for {low,...,up}, proposed for a new file interval.mlw in stdlib</h2>
<pre><span class="keyword1">module</span> <a name="Interval_">Interval</a>

  <span class="keyword1">use</span> int.<a href="int.html#Int_">Int</a>

  <span class="keyword1">val</span> <span class="keyword1">constant</span> <a name="low_115">low</a> : int <span class="comment">(* lower interval endpoint *)</span>
  <span class="keyword1">val</span> <span class="keyword1">constant</span>  <a name="up_116">up</a> : int <span class="comment">(* upper interval endpoint *)</span>
  <span class="keyword1">axiom</span> <a name="Nonempty_117">Nonempty</a> : <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a>

  <span class="keyword1">type</span> <a name="bint_119">bint</a> = {
    <a name="to_int_120">to_int</a>: int
  } <span class="keyword2">invariant</span> { <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> to_int <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> }
    <span class="keyword1">by</span> { to_int = <a href="#low_115">low</a> }
</pre>
<div class="info"><p>Type for the interval of all integers between <code>low</code> and <code>up</code> included.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">constant</span> <a name="low_bint_125">low_bint</a> : <a href="#bint_119">bint</a> = { <a href="#to_int_120">to_int</a> = <a href="#low_115">low</a> }

  <span class="keyword1">meta</span> coercion <span class="keyword1">function</span> <a href="#to_int_120">to_int</a>

  <span class="keyword1">axiom</span> <a name="Extensionality_129">Extensionality</a> : <span class="keyword1">forall</span> i j:<a href="#bint_119">bint</a>. <a href="#to_int_120">to_int</a> i = <a href="#to_int_120">to_int</a> j -&gt; i = j
</pre>
<div class="info"><p>This property holds for records without invariant, but cannot be proved here.
      We admit it. It entails <code>Trichotomy</code>.</p>
</div><pre>  <span class="keyword1">let</span> (<a name="infix%20=_133">=</a>) (i j: <a href="#bint_119">bint</a>) : bool = <a href="#to_int_120">to_int</a> i <a href="int.html#infix%20=_16">=</a> <a href="#to_int_120">to_int</a> j

  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="lt_bint_135">lt_bint</a> (i j: <a href="#bint_119">bint</a>) = <a href="#to_int_120">to_int</a> i <a href="int.html#infix%20%3C_21">&lt;</a> <a href="#to_int_120">to_int</a> j

  <span class="keyword1">clone</span> relations.<a href="relations.html#TotalStrictOrder_">TotalStrictOrder</a> <span class="keyword1">with</span>
  <span class="keyword1">type</span> <a href="relations.html#t_7">t</a> = <a href="#bint_119">bint</a>, <span class="keyword1">predicate</span> <a href="relations.html#rel_8">rel</a> = <a href="#lt_bint_135">lt_bint</a>
</pre>
<div class="info"><p><code>lt_bint</code> is a strict total order. <code>Trichotomy</code> is a consequence of axiom <code>Extensionality</code>.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="of_int_142">of_int</a> (i:int) : <a href="#bint_119">bint</a>
    <span class="keyword2">requires</span> { <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> }
    <span class="keyword2">ensures</span>  { result.<a href="#to_int_120">to_int</a> = i }
  =
    { <a href="#to_int_120">to_int</a> = i }
</pre>
<div class="info"><p>Constructor of <code>bint</code> inhabitants.</p>
</div><pre>  <span class="keyword1">lemma</span> <a name="of_int_quasi_inj_148">of_int_quasi_inj</a> :
    <span class="keyword1">forall</span> i j: int. <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> -&gt; <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> j <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> -&gt; <a href="#of_int_142">of_int</a> i = <a href="#of_int_142">of_int</a> j -&gt; i = j

  <span class="keyword1">lemma</span> <a name="of_intK_151">of_intK</a>: <span class="keyword1">forall</span> i:<a href="#bint_119">bint</a>. <a href="#of_int_142">of_int</a> (<a href="#to_int_120">to_int</a> i) = i

  <span class="keyword1">use</span> int.<a href="int.html#NumOf_">NumOf</a>

  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="numof_bint_155">numof_bint</a> (p: <a href="#bint_119">bint</a> -&gt; bool) (a b: <a href="#bint_119">bint</a>) : int
  =
    <a href="int.html#numof_317">numof</a> (<span class="keyword1">fun</span> (i:int) -&gt; <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> &amp;&amp; p (<a href="#of_int_142">of_int</a> i)) a.<a href="#to_int_120">to_int</a> b.<a href="#to_int_120">to_int</a>
</pre>
<div class="info"><p><code>numof_bint p a b</code> is the number of integers n such that <code>a</code> &lt;= n &lt; <code>b</code> and <code>p n</code> holds.</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>5. Theory Of One Bijection</h2>
<pre><span class="keyword1">module</span> <a name="TOOB_">TOOB</a>

  <span class="keyword1">type</span> <a name="t_167">t</a>
  <span class="keyword1">predicate</span> <a name="rel_168">rel</a> <a href="#t_167">t</a> <a href="#t_167">t</a></pre>
<div class="info"><p><code>rel</code> is R in [ABF20].</p>
</div><pre>  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Bijectivity_">Bijectivity</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_20">t</a> = <a href="#t_167">t</a>, <span class="keyword1">type</span> <a href="#u_21">u</a> = <a href="#t_167">t</a>, <span class="keyword1">predicate</span> <a href="#rel_22">rel</a> = <a href="#rel_168">rel</a>, <span class="keyword1">axiom</span> .

<span class="keyword1">end</span>

</pre>
<h2>6. Models for TOOB</h2>
<p>Hereafter we only consider models where permutations are endomaps on the 
    type <code>bint</code> satisfying the predicate <code>MapInjSurjBij.bijective</code>.</p>
<pre><span class="keyword1">module</span> <a name="ModelTOOB_">ModelTOOB</a>

  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>
  <span class="keyword1">use</span> <a href="#Interval_">Interval</a>
  <span class="keyword1">use</span> <a href="#MapInjSurjBij_">MapInjSurjBij</a>

  <span class="keyword1">val</span> <span class="keyword1">constant</span> <a name="sigma_187">sigma</a> : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>
  <span class="keyword1">axiom</span> <a name="sigma_bij_188">sigma_bij</a> : <a href="#bijective_87">bijective</a> <a href="#sigma_187">sigma</a>
</pre>
<div class="info"><p>Permutation model.</p>
</div><pre>  <span class="keyword1">clone</span> <a href="#MapRelation_">MapRelation</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_55">t</a> = <a href="#bint_119">bint</a>, <span class="keyword1">type</span> <a href="#u_56">u</a> = <a href="#bint_119">bint</a>, <span class="keyword1">constant</span> <a href="#m_62">m</a> = <a href="#sigma_187">sigma</a>, <span class="keyword1">axiom</span> <a href="#Deter_27">Deter</a>, <span class="keyword1">axiom</span> <a href="#Total_32">Total</a>
</pre>
<div class="info"><p>Provides <code>map_rel</code> and the properties that the graph of <code>sigma</code> is deterministic and total.</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="rel_sigma_194">rel_sigma</a> (i j: <a href="#bint_119">bint</a>) = <a href="#map_rel_59">map_rel</a> <a href="#sigma_187">sigma</a> i j
</pre>
<div class="info"><p>Relation associated to the permutation <code>sigma</code>.</p>
</div><pre>  <span class="keyword1">clone</span> <a href="#TOOB_">TOOB</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_167">t</a> = <a href="#bint_119">bint</a>, <span class="keyword1">predicate</span> <a href="#rel_168">rel</a> = <a href="#rel_sigma_194">rel_sigma</a>
</pre>
<div class="info"><p>The pair (<code>bint</code>,<code>rel_sigma</code>) forms a (permutation) model of TOOB.
      Axioms <code>Deter</code> and <code>Injec</code> are automatically proved with Alt-Ergo.
      Axiom <code>Total</code> is proved by Z3.
      Axiom <code>Surjec</code> is interactively proved with inline_all; CVC4 1.6.</p>
</div><pre><span class="keyword1">end</span>

<span class="keyword1">module</span> <a name="Proposition2_">Proposition2</a>

  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>
  <span class="keyword1">use</span> <a href="#Interval_">Interval</a>
  <span class="keyword1">use</span> <a href="#MapInjSurjBij_">MapInjSurjBij</a>

  <span class="keyword1">type</span> <a name="a_212">a</a>
  <span class="keyword1">predicate</span> <a name="rel_213">rel</a> <a href="#a_212">a</a> <a href="#a_212">a</a>
  <span class="keyword1">clone</span> <a href="#TOOB_">TOOB</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_167">t</a> = <a href="#a_212">a</a>, <span class="keyword1">predicate</span> <a href="#rel_168">rel</a> = <a href="#rel_213">rel</a>, <span class="keyword1">axiom</span> .
</pre>
<div class="info"><p>A model of TOOB is a pair (<code>a</code>,<code>rel</code>) satisfying all axioms of TOOB.</p>
</div><pre>  <span class="keyword1">function</span> <a name="a2bint_218">a2bint</a> <a href="#a_212">a</a> : <a href="#bint_119">bint</a>
  <span class="keyword1">function</span> <a name="bint2a_219">bint2a</a> <a href="#bint_119">bint</a> : <a href="#a_212">a</a>
  <span class="keyword1">clone</span> functions.<a href="functions.html#Bijective_">Bijective</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="functions.html#t_17">t</a> = <a href="#a_212">a</a>, <span class="keyword1">type</span> <a href="functions.html#u_18">u</a> = <a href="#bint_119">bint</a>,
    <span class="keyword1">function</span> <a href="functions.html#t2u_19">t2u</a> = <a href="#a2bint_218">a2bint</a>, <span class="keyword1">function</span> <a href="functions.html#u2t_20">u2t</a> = <a href="#bint2a_219">bint2a</a>, <span class="keyword1">axiom</span> <a href="functions.html#Cancel_22">Cancel</a>, <span class="keyword1">axiom</span> Right.<a href="functions.html#Cancel_22">Cancel</a>
</pre>
<div class="info"><p>The property that <code>a</code> is finite is specified by the existence of a pair of mutually
      inverse bijections with <code>bint</code>.</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="map_rel_224">map_rel</a> (m: <a href="map.html#map_9">map</a> 'a 'b) (x: 'a) (y: 'b) = (m[x] = y)
</pre>
<div class="info"><p>Binary relation associated to any map, as its graph.</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="isomorphic_226">isomorphic</a> (sigma : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>) =
    <span class="keyword1">exists</span> f: <a href="map.html#map_9">map</a> <a href="#a_212">a</a> <a href="#bint_119">bint</a>. <a href="#bijective_87">bijective</a> f /\ <span class="keyword1">forall</span> x y:<a href="#a_212">a</a>. <a href="#rel_213">rel</a> x y &lt;-&gt; <a href="#map_rel_224">map_rel</a> sigma (f x) (f y)
</pre>
<div class="info"><p><code>(isomorphic sigma)</code> holds iff (<code>a</code>,<code>rel</code>) and (<code>bint</code>,<code>map_rel sigma</code>) are isomorphic.</p>
</div><pre>  <span class="keyword1">lemma</span> <a name="ex_rel_permut_230">ex_rel_permut</a> : <span class="keyword1">exists</span> rel_permut : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>.
    <span class="keyword1">forall</span> i j:<a href="#bint_119">bint</a>. rel_permut[i] = j &lt;-&gt; <a href="#rel_213">rel</a> (<a href="#bint2a_219">bint2a</a> i) (<a href="#bint2a_219">bint2a</a> j)
</pre>
<div class="info"><p>Key lemma for the proof of Proposition 2, proved with Coq.</p>
</div><pre>  <span class="keyword1">lemma</span> <a name="Proposition2_234">Proposition2</a> : <span class="keyword1">exists</span> sigma: <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>. <a href="#bijective_87">bijective</a> sigma /\ <a href="#isomorphic_226">isomorphic</a> sigma
</pre>
<div class="info"><p>[ABF20, Proposition 2]. Not proved with Auto Level 3. Proved interactively with Why3.</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>7. Theory Of Two Orders</h2>
<pre><span class="keyword1">module</span> <a name="TOTO_">TOTO</a>

  <span class="keyword1">type</span> <a name="t_244">t</a>            <span class="comment">(* type of positions and values    *)</span>
  <span class="keyword1">predicate</span> <a name="ltP_245">ltP</a> <a href="#t_244">t</a> <a href="#t_244">t</a> <span class="comment">(* strict total order on positions *)</span>
  <span class="keyword1">predicate</span> <a name="ltV_246">ltV</a> <a href="#t_244">t</a> <a href="#t_244">t</a> <span class="comment">(* strict total order on values    *)</span>

  <span class="keyword1">clone</span> <span class="keyword1">export</span> relations.<a href="relations.html#TotalStrictOrder_">TotalStrictOrder</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="relations.html#t_7">t</a> = <a href="#t_244">t</a>, <span class="keyword1">predicate</span> <a href="relations.html#rel_8">rel</a> = <a href="#ltP_245">ltP</a>, <span class="keyword1">axiom</span> .
  <span class="keyword1">clone</span> relations.<a href="relations.html#TotalStrictOrder_">TotalStrictOrder</a> <span class="keyword1">as</span> V <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="relations.html#t_7">t</a> = <a href="#t_244">t</a>, <span class="keyword1">predicate</span> <a href="relations.html#rel_8">rel</a> = <a href="#ltV_246">ltV</a>, <span class="keyword1">axiom</span> .

<span class="keyword1">end</span>

</pre>
<h2>8. Type for the arcs of the graph of a map</h2>
<pre><span class="keyword1">module</span> <a name="MapGraph_">MapGraph</a>

  <span class="keyword1">use</span> int.<a href="int.html#Int_">Int</a>
  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>
  <span class="keyword1">use</span> <a href="#Interval_">Interval</a>

  <span class="keyword1">constant</span> <a name="m_262">m</a> : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>
  <span class="keyword1">type</span> <a name="arrow_263">arrow</a> = {
    <a name="source_264">source</a> : <a href="#bint_119">bint</a>;
    <a name="target_265">target</a> : <a href="#bint_119">bint</a>
  } <span class="keyword2">invariant</span> { target = <a href="#m_262">m</a>[source] }
    <span class="keyword1">by</span> { source = <a href="#low_bint_125">low_bint</a>; target = <a href="#m_262">m</a>[<a href="#low_bint_125">low_bint</a>] }
</pre>
<div class="info"><p>Type for (i,<code>m</code>(i)), for <code>low</code> &lt;= i &lt;= <code>up</code>.</p>
</div><pre>  <span class="keyword1">axiom</span> <a name="Extensionality_270">Extensionality</a>: <span class="keyword1">forall</span> a b:<a href="#arrow_263">arrow</a>. a.<a href="#source_264">source</a> = b.<a href="#source_264">source</a> /\ a.<a href="#target_265">target</a> = b.<a href="#target_265">target</a> -&gt; a = b
</pre>
<div class="info"><p>Extensionality of logical equality on <code>arrow</code>. This axiom is necessary to
      prove <code>Trichotomy</code>.</p>
</div><pre>  <span class="keyword1">let</span> (<a name="infix%20=_274">=</a>) (a b: <a href="#arrow_263">arrow</a>) : bool = a.<a href="#source_264">source</a> <a href="int.html#infix%20=_16">=</a> b.<a href="#source_264">source</a> &amp;&amp; a.<a href="#target_265">target</a> <a href="int.html#infix%20=_16">=</a> b.<a href="#target_265">target</a>

  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="lt_source_276">lt_source</a> (a b: <a href="#arrow_263">arrow</a>) = <a href="#lt_bint_135">lt_bint</a> a.<a href="#source_264">source</a> b.<a href="#source_264">source</a>
</pre>
<div class="info"><p>Strict total order on type <code>arrow</code>.</p>
</div><pre>  <span class="keyword1">clone</span> <span class="keyword1">export</span> relations.<a href="relations.html#TotalStrictOrder_">TotalStrictOrder</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="relations.html#t_7">t</a> = <a href="#arrow_263">arrow</a>, <span class="keyword1">predicate</span> <a href="relations.html#rel_8">rel</a> = <a href="#lt_source_276">lt_source</a>

  <span class="keyword1">lemma</span> <a name="Source_inj_280">Source_inj</a>: <span class="keyword1">forall</span> a b:<a href="#arrow_263">arrow</a>. a.<a href="#source_264">source</a> = b.<a href="#source_264">source</a> -&gt; a = b
</pre>
<div class="info"><p>The <code>source</code> field determines the value of the <code>target</code> field.</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>9. Models for TOTO</h2>
<pre><span class="keyword1">module</span> <a name="ModelTOTO_">ModelTOTO</a>

  <span class="keyword1">use</span> int.<a href="int.html#Int_">Int</a>
  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>
  <span class="keyword1">use</span> <a href="#Interval_">Interval</a>
  <span class="keyword1">use</span> <a href="#MapInjSurjBij_">MapInjSurjBij</a>

  <span class="keyword1">constant</span> <a name="sigma_295">sigma</a> : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>
  <span class="keyword1">axiom</span> <a name="sigma_bij_296">sigma_bij</a> : <a href="#bijective_87">bijective</a> <a href="#sigma_295">sigma</a>

  <span class="keyword1">clone</span> <a href="#MapGraph_">MapGraph</a> <span class="keyword1">with</span> <span class="keyword1">constant</span> <a href="#m_262">m</a> = <a href="#sigma_295">sigma</a>, <span class="keyword1">axiom</span> <a href="#Extensionality_270">Extensionality</a> <span class="comment">(* provides type arrow, etc *)</span>

  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="ltP_sigma_300">ltP_sigma</a> (a b: <a href="#arrow_263">arrow</a>) = <a href="#lt_bint_135">lt_bint</a> a.<a href="#source_264">source</a> b.<a href="#source_264">source</a>
  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="ltV_sigma_301">ltV_sigma</a> (a b: <a href="#arrow_263">arrow</a>) = <a href="#lt_bint_135">lt_bint</a> a.<a href="#target_265">target</a> b.<a href="#target_265">target</a>

  <span class="keyword1">clone</span> <a href="#TOTO_">TOTO</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_244">t</a> = <a href="#arrow_263">arrow</a>, <span class="keyword1">predicate</span> <a href="#ltP_245">ltP</a> = <a href="#ltP_sigma_300">ltP_sigma</a>, <span class="keyword1">predicate</span> <a href="#ltV_246">ltV</a> = <a href="#ltV_sigma_301">ltV_sigma</a>

<span class="keyword1">end</span>

</pre>
<h1>Restriction to integer intervals for simpler constructions and proofs</h1>

<p>Hereafter we abandon the objectives of fidelity to [ABF20] and universality of logic with any support set,
 and we focus on types <code>int</code> and <code>bint</code>. Thus we get shorter definitions and computable predicates and functions.</p>
<h2>1. Strict Total Order on one integer Interval</h2>
<pre><span class="keyword1">module</span> <a name="STOI_">STOI</a>

  <span class="keyword1">type</span> <a name="t_318">t</a>

  <span class="keyword1">val</span> <span class="keyword1">predicate</span> <a name="lt_320">lt</a> <a href="#t_318">t</a> <a href="#t_318">t</a>
  <span class="keyword1">clone</span> <span class="keyword1">export</span> relations.<a href="relations.html#TotalStrictOrder_">TotalStrictOrder</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="relations.html#t_7">t</a> = <a href="#t_318">t</a>, <span class="keyword1">predicate</span> <a href="relations.html#rel_8">rel</a> = <a href="#lt_320">lt</a>, <span class="keyword1">axiom</span> .

  <span class="keyword1">clone</span> <span class="keyword1">export</span> relations.<a href="relations.html#Irreflexive_">Irreflexive</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="relations.html#t_7">t</a> = <a href="#t_318">t</a>, <span class="keyword1">predicate</span> <a href="relations.html#rel_8">rel</a> = <a href="#lt_320">lt</a>
</pre>
<div class="info"><p>Provides the property <code>Strict</code> that simplifies the Coq proof for <code>rank</code> injectivity.
      Similar to the following lemma:
  <code><span class="keyword1">lemma</span> Strict : <span class="keyword1">forall</span> i:bint. <span class="keyword1">not</span> (lt i i)</code></p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>2. Permutation model for STOI</h2>
<h3>2.1. From a permutation over [1..<code>size</code>]</h3>
<pre><span class="keyword1">module</span> <a name="Gio20proposition5_">Gio20proposition5</a> <span class="comment">(* [Gio20, Proposition 5] *)</span>

  <span class="keyword1">use</span> int.<a href="int.html#Int_">Int</a>
  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>
  <span class="keyword1">use</span> <a href="#MapInjSurjBij_">MapInjSurjBij</a>

  <span class="keyword1">val</span> <span class="keyword1">constant</span> <a name="size_341">size</a> : int

  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Interval_">Interval</a> <span class="keyword1">with</span> <span class="keyword1">val</span> <a href="#low_115">low</a> = <a href="int.html#one_14">one</a>, <span class="keyword1">val</span> <a href="#up_116">up</a> = <a href="#size_341">size</a>, <span class="keyword1">axiom</span> .
</pre>
<div class="info"><p>Defines <code>bint</code> as a type for the interval [<code>one</code>..<code>size</code>]. 1 &lt;= <code>size</code> is assumed.</p>
</div><pre>  <span class="keyword1">val</span> <span class="keyword1">constant</span> <a name="sigma_346">sigma</a> : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>
  <span class="keyword1">axiom</span> <a name="sigma_bij_347">sigma_bij</a> : <a href="#bijective_87">bijective</a> <a href="#sigma_346">sigma</a>

  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="lt_sigma_349">lt_sigma</a> (i j: <a href="#bint_119">bint</a>) = <a href="#lt_bint_135">lt_bint</a> (<a href="#sigma_346">sigma</a> i) (<a href="#sigma_346">sigma</a> j)

  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#STOI_">STOI</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="#t_318">t</a> = <a href="#bint_119">bint</a>, <span class="keyword1">val</span> <a href="#lt_320">lt</a> = <a href="#lt_sigma_349">lt_sigma</a>
</pre>
<div class="info"><p>The pair ([<code>one</code>..<code>size</code>],<code>lt_sigma</code>) is a (permutation) model of STOI.</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h3>2.2. From a permutation over any interval [<code>low</code>..<code>up</code>]</h3>
<pre><span class="keyword1">module</span> <a name="ModelSTOI_">ModelSTOI</a> <span class="comment">(* [Gio21, Section 4, Paragraph 2] *)</span>

  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>
  <span class="keyword1">use</span> <a href="#MapInjSurjBij_">MapInjSurjBij</a>

  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Interval_">Interval</a> <span class="keyword1">with</span> <span class="keyword1">axiom</span> .
</pre>
<div class="info"><p>Defines <code>bint</code> as a type for the interval [<code>low</code>..<code>up</code>]. <code>low</code> &lt;= <code>up</code> is assumed.</p>
</div><pre>  <span class="keyword1">val</span> <span class="keyword1">constant</span> <a name="sigma_367">sigma</a> : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>
  <span class="keyword1">axiom</span> <a name="sigma_bij_368">sigma_bij</a> : <a href="#bijective_87">bijective</a> <a href="#sigma_367">sigma</a>

  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="lt_map_370">lt_map</a> (m: <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>) (i j: <a href="#bint_119">bint</a>) = <a href="#lt_bint_135">lt_bint</a> m[i] m[j]
  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="lt_sigma_371">lt_sigma</a> (i j: <a href="#bint_119">bint</a>) = <a href="#lt_map_370">lt_map</a> <a href="#sigma_367">sigma</a> i j

  <span class="keyword1">clone</span> <span class="keyword1">export</span> relations.<a href="relations.html#TotalStrictOrder_">TotalStrictOrder</a> <span class="keyword1">with</span> <span class="keyword1">type</span> <a href="relations.html#t_7">t</a> = <a href="#bint_119">bint</a>, <span class="keyword1">predicate</span> <a href="relations.html#rel_8">rel</a> = <a href="#lt_sigma_371">lt_sigma</a>
</pre>
<div class="info"><p>The pair ([<code>low</code>..<code>up</code>],<code>lt_sigma</code>) is a (permutation) model of STOI.</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>3. Two mutually inverse permutations associated to a strict total order</h2>

<p>[ABF20] defines a rank function to associate a permutation to any model of TOTO, composed of two strict
 total orders. Here we associate a rank function to any strict total order on <code>bint</code>. Its type requires
 a proof that its range is <code>bint</code>. Then we prove (with Coq) that <code>rank lt</code> is injective for any strict
 total order <code>lt</code>. Surjectivity is more difficult to prove. We implement a candidate for an inverse 
 function (not in [ABF20]). This implementation goes through a constructive definition of the minimum 
 and maximum of a strict total order on <code>bint</code>, and of a function <code>succ</code>.</p>
<pre><span class="keyword1">module</span> <a name="Rank_">Rank</a>

  <span class="keyword1">use</span> <span class="keyword1">ref</span>.<a href="ref.html#Ref_">Ref</a>
  <span class="keyword1">use</span> int.<a href="int.html#Int_">Int</a>
  <span class="keyword1">use</span> int.<a href="int.html#NumOf_">NumOf</a>
  <span class="keyword1">use</span> map.<a href="map.html#Map_">Map</a>
  <span class="keyword1">use</span> <a href="#NumOfExt_">NumOfExt</a>
  <span class="keyword1">use</span> <a href="#MapInjSurjBij_">MapInjSurjBij</a>

  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Interval_">Interval</a> <span class="keyword1">with</span> <span class="keyword1">axiom</span> .
</pre>
<div class="info"><p>All that follows is defined for the clones of <code>low</code>, <code>up</code> and <code>bint</code> introduced here.</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="trans_400">trans</a> (rel : 'a -&gt; 'a -&gt; bool) = <span class="keyword1">forall</span> x y z:'a. rel x y -&gt; rel y z -&gt; rel x z
  <span class="keyword1">predicate</span> <a name="asymm_401">asymm</a> (rel : 'a -&gt; 'a -&gt; bool) = <span class="keyword1">forall</span> x y:'a. rel x y -&gt; <span class="keyword1">not</span> rel y x
  <span class="keyword1">predicate</span> <a name="partialStrictOrder_402">partialStrictOrder</a> (rel : 'a -&gt; 'a -&gt; bool) = <a href="#trans_400">trans</a> rel /\ <a href="#asymm_401">asymm</a> rel
  <span class="keyword1">predicate</span> <a name="trichotomy_403">trichotomy</a> (rel : 'a -&gt; 'a -&gt; bool) = <span class="keyword1">forall</span> x y:'a. rel x y \/ rel y x \/ x = y
  <span class="keyword1">predicate</span> <a name="totalStrictOrder_404">totalStrictOrder</a> (rel : 'a -&gt; 'a -&gt; bool) = <a href="#partialStrictOrder_402">partialStrictOrder</a> rel /\ <a href="#trichotomy_403">trichotomy</a> rel

  <span class="keyword1">lemma</span> <a name="irrefl_406">irrefl</a> :
    <span class="keyword1">forall</span> lt : 'a -&gt; 'a -&gt; bool. <a href="#asymm_401">asymm</a> lt -&gt; <span class="keyword1">forall</span> a:'a. lt a a = <span class="keyword1">false</span>
</pre>
<div class="info"><p>An asymmetric relation <code>lt</code> is irreflexive. Helps the proofs of <code>numof_max</code> and <code>rank'vc</code>.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="lt_int_410">lt_int</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (a:<a href="#bint_119">bint</a>) (j:int) = <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> j <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> &amp;&amp; lt (<a href="#of_int_142">of_int</a> j) a

  <span class="keyword1">lemma</span> <a name="numof_max_412">numof_max</a> : <span class="keyword1">forall</span> lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool. <a href="#asymm_401">asymm</a> lt -&gt;
    <span class="keyword1">forall</span> a:<a href="#bint_119">bint</a>. <a href="int.html#numof_317">numof</a> (<a href="#lt_int_410">lt_int</a> lt a) <a href="#low_115">low</a> (<a href="#up_116">up</a><a href="int.html#infix%20+_19">+</a>1) <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> <a href="int.html#infix%20-_23">-</a> <a href="#low_115">low</a>
</pre>
<div class="info"><p>Consequence of irreflexivity of <code>lt</code> and lemma <code>Numof_no_add</code>.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">predicate</span> <a name="lt_map_416">lt_map</a> (m: <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>) (i j:<a href="#bint_119">bint</a>) = <a href="#lt_bint_135">lt_bint</a> m[i] m[j]

  <span class="keyword1">lemma</span> <a name="lt_map_bij_sto_418">lt_map_bij_sto</a>: <span class="keyword1">forall</span> sigma : <a href="map.html#map_9">map</a> <a href="#bint_119">bint</a> <a href="#bint_119">bint</a>. <a href="#bijective_87">bijective</a> sigma -&gt;
    <a href="#totalStrictOrder_404">totalStrictOrder</a> (<span class="keyword1">fun</span> i -&gt; <span class="keyword1">fun</span> j -&gt; <a href="#lt_map_416">lt_map</a> sigma i j)
</pre>
<div class="info"><p>The image of a bijective application by <code>lt_map</code> is a total strict order.
      Similar to ModelSTOI but with Boolean functions instead of predicates.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="rank_423">rank</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (a:<a href="#bint_119">bint</a>) : <a href="#bint_119">bint</a>
    <span class="keyword2">requires</span> { <a href="#totalStrictOrder_404">totalStrictOrder</a> lt }
  =
    <a href="#of_int_142">of_int</a> ((<a href="int.html#numof_317">numof</a> (<a href="#lt_int_410">lt_int</a> lt a) <a href="#low_115">low</a> (<a href="#up_116">up</a><a href="int.html#infix%20+_19">+</a>1)) <a href="int.html#infix%20+_19">+</a> <a href="#low_115">low</a>)
</pre>
<div class="info"><p><code>rank'vc</code> is about the range of <code>rank</code>.
      The lower bound is a consequence of lemma int.NumOf.Numof_bounds.
      The upper bound is a consequence of <code>numof_max</code>.</p>
</div><pre>  <span class="keyword1">lemma</span> <a name="rank_lt_inj_431">rank_lt_inj</a>: <span class="keyword1">forall</span> lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool. <a href="#totalStrictOrder_404">totalStrictOrder</a> lt -&gt; <a href="#injective_81">injective</a> (<a href="#rank_423">rank</a> lt)
</pre>
<div class="info"><p>If <code>lt</code> is a strict total order then <code>rank lt</code> is injective.</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="is_max_left_434">is_max_left</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (m:<a href="#bint_119">bint</a>) (i:int) =
    <span class="keyword1">forall</span> j. <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> j <a href="int.html#infix%20%3C=_25">&lt;=</a> i -&gt; lt (<a href="#of_int_142">of_int</a> j) m \/ <a href="#of_int_142">of_int</a> j = m
</pre>
<div class="info"><p><code>(is_max_left lt m i)</code> iff <code>m</code> is the maximum of <code>lt</code> on [<code>of_int low</code>..<code>of_int i</code>].</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="is_max_438">is_max</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (m:<a href="#bint_119">bint</a>) = <a href="#is_max_left_434">is_max_left</a> lt m <a href="#up_116">up</a>
</pre>
<div class="info"><p><code>(is_max lt m)</code> iff <code>m</code> is the maximum of <code>lt</code> on <code>bint</code>.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="max_441">max</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) : <a href="#bint_119">bint</a>
    <span class="keyword2">requires</span> { <a href="#totalStrictOrder_404">totalStrictOrder</a> lt }
    <span class="keyword2">ensures</span>  { <a href="#is_max_438">is_max</a> lt result }
  =
    <span class="keyword1">let</span> <span class="keyword1">ref</span> m = <a href="#of_int_142">of_int</a> <a href="#low_115">low</a> <span class="keyword1">in</span>
    <span class="keyword1">for</span> i = <a href="#low_115">low</a><a href="int.html#infix%20+_19">+</a>1 <span class="keyword1">to</span> <a href="#up_116">up</a> <span class="keyword1">do</span>
      <span class="keyword2">invariant</span> { <a href="#low_115">low</a><a href="int.html#infix%20+_19">+</a>1 <a href="int.html#infix%20%3C=_25">&lt;=</a> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a><a href="int.html#infix%20+_19">+</a>1 }
      <span class="keyword2">invariant</span> { <a href="#is_max_left_434">is_max_left</a> lt m (i<a href="int.html#infix%20-_23">-</a>1) }
      <span class="keyword1">let</span> j = <a href="#of_int_142">of_int</a> i <span class="keyword1">in</span>
      <span class="keyword1">if</span> lt m j <span class="keyword1">then</span> m <a href="ref.html#infix%20:=_20">:=</a> j
    <span class="keyword1">done</span>;
    m
</pre>
<div class="info"><p><code>max lt</code> is the maximal number for <code>lt</code>.</p>
</div><pre>  <span class="keyword1">lemma</span> <a name="max_is_max_455">max_is_max</a> : <span class="keyword1">forall</span> lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool. <a href="#totalStrictOrder_404">totalStrictOrder</a> lt -&gt;
    <span class="keyword1">forall</span> a. a = <a href="#max_441">max</a> lt &lt;-&gt; <a href="#is_max_438">is_max</a> lt a

  <span class="keyword1">predicate</span> <a name="is_succ_left_458">is_succ_left</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (a b:<a href="#bint_119">bint</a>) (i:int) = lt a b /\
    <span class="keyword1">forall</span> j. <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> j <a href="int.html#infix%20%3C=_25">&lt;=</a> i -&gt; <span class="keyword1">let</span> c = <a href="#of_int_142">of_int</a> j <span class="keyword1">in</span> <span class="keyword1">not</span> (lt a c &amp;&amp; lt c b)

  <span class="keyword1">predicate</span> <a name="is_succ_461">is_succ</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (a b:<a href="#bint_119">bint</a>) = <a href="#is_succ_left_458">is_succ_left</a> lt a b <a href="#up_116">up</a>

  <span class="keyword1">let</span> <a name="succ_463">succ</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (a:<a href="#bint_119">bint</a>) : <a href="#bint_119">bint</a>
    <span class="keyword2">requires</span> { <a href="#totalStrictOrder_404">totalStrictOrder</a> lt }
    <span class="keyword2">requires</span> { a &lt;&gt; <a href="#max_441">max</a> lt }
    <span class="keyword2">ensures</span>  { <a href="#is_succ_461">is_succ</a> lt a result }
  =
    <span class="keyword1">let</span> <span class="keyword1">ref</span> i = <a href="#low_115">low</a> <span class="keyword1">in</span>
    <span class="keyword1">while</span> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> &amp;&amp; <span class="keyword1">not</span> (lt a (<a href="#of_int_142">of_int</a> i)) <span class="keyword1">do</span>  <span class="comment">(* the first loop searches some (of_int i) greater than a *)</span>
      <span class="keyword2">invariant</span> { <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a><a href="int.html#infix%20+_19">+</a>1 }
      <span class="keyword2">invariant</span> { <span class="keyword1">forall</span> j. <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> j <a href="int.html#infix%20%3C_21">&lt;</a> i -&gt; <span class="keyword1">not</span> (lt a (<a href="#of_int_142">of_int</a> j)) }
      <span class="keyword2">variant</span> { <a href="#up_116">up</a> <a href="int.html#infix%20-_23">-</a> i }
      i <a href="ref.html#infix%20:=_20">:=</a> i<a href="int.html#infix%20+_19">+</a>1
    <span class="keyword1">done</span>;
    <span class="keyword1">let</span> <span class="keyword1">ref</span> b = <a href="#of_int_142">of_int</a> i <span class="keyword1">in</span> <span class="comment">(* candidate for (succ a) *)</span>
    i <a href="ref.html#infix%20:=_20">:=</a> i<a href="int.html#infix%20+_19">+</a>1;
    <span class="keyword1">while</span> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a> <span class="keyword1">do</span> <span class="comment">(* the second loop improves this (of_int i) greater than a *)</span>
      <span class="keyword2">invariant</span> { <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a><a href="int.html#infix%20+_19">+</a>1 }
      <span class="keyword2">invariant</span> { <a href="#is_succ_left_458">is_succ_left</a> lt a b (i<a href="int.html#infix%20-_23">-</a>1) }
      <span class="keyword2">variant</span> { <a href="#up_116">up</a> <a href="int.html#infix%20-_23">-</a> i }
      <span class="keyword1">let</span> k = <a href="#of_int_142">of_int</a> i <span class="keyword1">in</span>
      <span class="keyword1">if</span> lt a k &amp;&amp; lt k b <span class="keyword1">then</span> b <a href="ref.html#infix%20:=_20">:=</a> k;
      i <a href="ref.html#infix%20:=_20">:=</a> i<a href="int.html#infix%20+_19">+</a>1
    <span class="keyword1">done</span>;
    b
</pre>
<div class="info"><p>Proved with &#39;Auto Level 3&#39;.</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="is_min_left_488">is_min_left</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (m:<a href="#bint_119">bint</a>) (i:int) =
    <span class="keyword1">forall</span> j. <a href="#low_115">low</a> <a href="int.html#infix%20%3C=_25">&lt;=</a> j <a href="int.html#infix%20%3C=_25">&lt;=</a> i -&gt; lt m (<a href="#of_int_142">of_int</a> j) \/ m = <a href="#of_int_142">of_int</a> j
</pre>
<div class="info"><p><code>(is_min_left lt m i)</code> iff <code>m</code> is the minimum of <code>lt</code> on [<code>of_int low</code>..<code>of_int i</code>].</p>
</div><pre>  <span class="keyword1">predicate</span> <a name="is_min_492">is_min</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (m:<a href="#bint_119">bint</a>) = <a href="#is_min_left_488">is_min_left</a> lt m <a href="#up_116">up</a>
</pre>
<div class="info"><p><code>(is_min lt m)</code> iff <code>m</code> is the minimum of <code>lt</code> on <code>bint</code>.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="min_495">min</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) : <a href="#bint_119">bint</a>
    <span class="keyword2">requires</span> { <a href="#totalStrictOrder_404">totalStrictOrder</a> lt }
    <span class="keyword2">ensures</span>  { <a href="#is_min_492">is_min</a> lt result }
  =
    <span class="keyword1">let</span> <span class="keyword1">ref</span> m = <a href="#of_int_142">of_int</a> <a href="#low_115">low</a> <span class="keyword1">in</span>
    <span class="keyword1">for</span> i = <a href="#low_115">low</a><a href="int.html#infix%20+_19">+</a>1 <span class="keyword1">to</span> <a href="#up_116">up</a> <span class="keyword1">do</span>
      <span class="keyword2">invariant</span> { <a href="#low_115">low</a><a href="int.html#infix%20+_19">+</a>1 <a href="int.html#infix%20%3C=_25">&lt;=</a> i <a href="int.html#infix%20%3C=_25">&lt;=</a> <a href="#up_116">up</a><a href="int.html#infix%20+_19">+</a>1 }
      <span class="keyword2">invariant</span> { <a href="#is_min_left_488">is_min_left</a> lt m (i<a href="int.html#infix%20-_23">-</a>1) }
      <span class="keyword1">let</span> j = <a href="#of_int_142">of_int</a> i <span class="keyword1">in</span>
      <span class="keyword1">if</span> lt j m <span class="keyword1">then</span> m <a href="ref.html#infix%20:=_20">:=</a> j
    <span class="keyword1">done</span>;
    m
</pre>
<div class="info"><p><code>min lt</code> is the minimal number for <code>lt</code>.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="unrank_509">unrank</a> (lt : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool) (i:<a href="#bint_119">bint</a>) : <a href="#bint_119">bint</a>
    <span class="keyword2">requires</span> { <a href="#totalStrictOrder_404">totalStrictOrder</a> lt }
  =
    <span class="keyword1">let</span> <span class="keyword1">ref</span> k = i.<a href="#to_int_120">to_int</a> <span class="keyword1">in</span>
    <span class="keyword1">let</span> <span class="keyword1">ref</span> j = <a href="#min_495">min</a> lt <span class="keyword1">in</span>
    <span class="keyword1">while</span> <span class="keyword1">not</span> (j <a href="int.html#infix%20=_16">=</a> <a href="#max_441">max</a> lt) &amp;&amp; k <a href="int.html#infix%20%3E_24">&gt;</a> <a href="#low_115">low</a> <span class="keyword1">do</span>
      <span class="keyword2">variant</span> { k<a href="int.html#infix%20+_19">+</a>1<a href="int.html#infix%20-_23">-</a><a href="#low_115">low</a> }
      j <a href="ref.html#infix%20:=_20">:=</a> <a href="#succ_463">succ</a> lt j;
      k <a href="ref.html#infix%20:=_20">:=</a> k<a href="int.html#infix%20-_23">-</a>1
    <span class="keyword1">done</span>;
    j

  <span class="keyword1">lemma</span> <a name="rank_ltK_521">rank_ltK</a>: <span class="keyword1">forall</span> lt. <a href="#totalStrictOrder_404">totalStrictOrder</a> lt -&gt; <span class="keyword1">forall</span> i. <a href="#rank_423">rank</a> lt (<a href="#unrank_509">unrank</a> lt i) = i
</pre>
<div class="info"><p><code>rank lt</code> is the left inverse of <code>unrank lt</code>. Tested in the module <code>Tests' below. </code></p>
</div><pre>  <span class="keyword1">lemma</span> <a name="unrank_ltK_524">unrank_ltK</a>: <span class="keyword1">forall</span> lt. <a href="#totalStrictOrder_404">totalStrictOrder</a> lt -&gt; <span class="keyword1">forall</span> i. <a href="#unrank_509">unrank</a> lt (<a href="#rank_423">rank</a> lt i) = i
</pre>
<div class="info"><p><code>unrank lt</code> is the left inverse of <code>rank lt</code>. Automatically proved with Alt-Ergo.
      Also interactively deduced in Coq from lemmas rank_ltK and rank_lt_inj.</p>
</div><pre>  <span class="keyword1">lemma</span> <a name="lt_mapK_528">lt_mapK</a>: <span class="keyword1">forall</span> lt. <a href="#totalStrictOrder_404">totalStrictOrder</a> lt -&gt; <a href="#lt_map_416">lt_map</a> (<a href="#rank_423">rank</a> lt) = lt

  <span class="keyword1">lemma</span> <a name="Proposition1_530">Proposition1</a>: <span class="keyword1">forall</span> lt. <a href="#totalStrictOrder_404">totalStrictOrder</a> lt -&gt;
    <span class="keyword1">exists</span> sigma. <a href="#bijective_87">bijective</a> sigma /\ <a href="#lt_map_416">lt_map</a> sigma = lt
</pre>
<div class="info"><p>Proposition 1 in [Gio21].</p>
</div><pre><span class="keyword1">end</span>

</pre>
<h2>4. Enumerative tests</h2>
<pre><span class="keyword1">module</span> <a name="Tests_">Tests</a>

  <span class="keyword1">use</span> int.<a href="int.html#Int_">Int</a>
  <span class="keyword1">use</span> array.<a href="array.html#Array_">Array</a>
  <span class="comment">(* Enumerative testing tool *)</span>
  <span class="keyword1">use</span> Enum.<a href="Enum.html#Permutation_">Permutation</a>
  <span class="keyword1">use</span> SCheck.<a href="SCheck.html#Test_">Test</a>
  <span class="keyword1">use</span> SCheck.<a href="SCheck.html#SCheck_">SCheck</a>
  <span class="keyword1">use</span> SCheck.<a href="SCheck.html#SCheck_runner_">SCheck_runner</a>

  <span class="keyword1">let</span> <span class="keyword1">constant</span> <a name="size_549">size</a> : int = 6
  <span class="keyword1">clone</span> <span class="keyword1">export</span> <a href="#Rank_">Rank</a> <span class="keyword1">with</span> <span class="keyword1">val</span> <a href="#low_115">low</a> = <a href="int.html#one_14">one</a>, <span class="keyword1">val</span> <a href="#up_116">up</a> = <a href="#size_549">size</a>, <span class="keyword1">axiom</span> .

  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="array_sto_553">array_sto</a> (a:{<a href="array.html#array_15">array</a> int}) : <a href="#bint_119">bint</a> -&gt; <a href="#bint_119">bint</a> -&gt; bool
    <span class="keyword2">requires</span> { a.<a href="array.html#length_17">length</a> = <a href="#size_549">size</a> /\ <a href="Enum.html#is_permut_1274">is_permut</a> a }
    <span class="keyword2">ensures</span>  { <a href="#totalStrictOrder_404">totalStrictOrder</a> result }
  =
    <span class="keyword1">fun</span> x -&gt; <span class="keyword1">fun</span> y -&gt; a[x.<a href="#to_int_120">to_int</a><a href="int.html#infix%20-_23">-</a><a href="int.html#one_14">one</a>] <a href="int.html#infix%20%3C_21">&lt;</a> a[y.<a href="#to_int_120">to_int</a><a href="int.html#infix%20-_23">-</a><a href="int.html#one_14">one</a>]
  <span class="comment">(* `-one` because `a` is on [0..n-1] whereas `bint` is [`one`..`size`] *)</span>
</pre>
<div class="info"><p>Strict total order associated to any permutation stored in an array of integers.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="rank_cancel_560">rank_cancel</a> lt : bool
    <span class="keyword2">requires</span> { <a href="#totalStrictOrder_404">totalStrictOrder</a> lt }
  =
    <span class="keyword1">for</span> i = <a href="int.html#one_14">one</a> <span class="keyword1">to</span> <a href="#size_549">size</a> <span class="keyword1">do</span>
      <span class="keyword1">let</span> j = <a href="#of_int_142">of_int</a> i <span class="keyword1">in</span>
      <span class="keyword1">if</span> <span class="keyword1">not</span> (<a href="#rank_423">rank</a> lt (<a href="#unrank_509">unrank</a> lt j) <a href="int.html#infix%20=_16">=</a> j) <span class="keyword1">then</span> <span class="keyword1">return</span> <span class="keyword1">false</span>
    <span class="keyword1">done</span>;
    <span class="keyword1">true</span>

  <span class="keyword1">let</span> <a name="rank_cancel_array_569">rank_cancel_array</a> (a:<a href="array.html#array_15">array</a> int) : bool
    <span class="keyword2">requires</span> { a.<a href="array.html#length_17">length</a> = <a href="#size_549">size</a> /\ <a href="Enum.html#is_permut_1274">is_permut</a> a }
  =
    <a href="#rank_cancel_560">rank_cancel</a> (<a href="#array_sto_553">array_sto</a> a)
</pre>
<div class="info"><p>Tested function.</p>
</div><pre>  <span class="keyword1">let</span> <span class="keyword1">function</span> <a name="rank_cancel_test_575">rank_cancel_test</a>
  =
    SCheck_runner.<a href="SCheck.html#run_tests_133">run_tests</a> (Test.<a href="SCheck.html#make_101">make</a> SCheck.(<a href="SCheck.html#permut_of_size_77">permut_of_size</a> <a href="#size_549">size</a>) <a href="#rank_cancel_array_569">rank_cancel_array</a>)
</pre>
<div class="info"><p>Enumerative test of rank_ltK.</p>
</div><pre><span class="keyword1">end</span></pre>

</div>
<hr>
<p>Generated by why3doc 1.3.3</p>
</body>
</html>
